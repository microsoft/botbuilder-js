## API Report File for "botbuilder-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from 'botframework-schema';
import { AdaptiveCardInvokeResponse } from 'botframework-schema';
import { AdaptiveCardInvokeValue } from 'botframework-schema';
import { AnimationCard } from 'botframework-schema';
import { Attachment } from 'botframework-schema';
import { AudioCard } from 'botframework-schema';
import { AuthenticateRequestResult } from 'botframework-connector';
import { AuthenticationConfiguration } from 'botframework-connector';
import { BotFrameworkAuthentication } from 'botframework-connector';
import { BotFrameworkClient } from 'botframework-connector';
import { CardAction } from 'botframework-schema';
import { CardImage } from 'botframework-schema';
import { ChannelAccount } from 'botframework-schema';
import { ClaimsIdentity } from 'botframework-connector';
import { Configuration } from 'botbuilder-dialogs-adaptive-runtime-core';
import { ConnectorClientOptions } from 'botframework-connector';
import { ConnectorFactory } from 'botframework-connector';
import { ConversationParameters } from 'botframework-schema';
import { ConversationReference } from 'botframework-schema';
import { HeroCard } from 'botframework-schema';
import { InputHints } from 'botframework-schema';
import { InvokeResponse } from 'botframework-schema';
import { MediaUrl } from 'botframework-schema';
import { Mention } from 'botframework-schema';
import { MessageReaction } from 'botframework-schema';
import { O365ConnectorCard } from 'botframework-schema';
import { PasswordServiceClientCredentialFactory } from 'botframework-connector';
import { ReceiptCard } from 'botframework-schema';
import { ResourceResponse } from 'botframework-schema';
import { SearchInvokeResponse } from 'botframework-schema';
import { SearchInvokeValue } from 'botframework-schema';
import { ServiceClientCredentials } from 'botframework-connector';
import { ServiceClientCredentialsFactory } from 'botframework-connector';
import { ServiceCollection } from 'botbuilder-dialogs-adaptive-runtime-core';
import { SignInUrlResponse } from 'botframework-schema';
import { StatusCodes } from 'botframework-schema';
import { ThumbnailCard } from 'botframework-schema';
import { TokenExchangeRequest } from 'botframework-schema';
import { TokenExchangeResource } from 'botframework-schema';
import { TokenPostResource } from 'botframework-schema';
import { TokenResponse } from 'botframework-schema';
import { UserTokenClient } from 'botframework-connector';
import { VideoCard } from 'botframework-schema';
import * as z from 'zod';

// @public
export class ActivityFactory {
    static fromObject(lgResult: any): Partial<Activity>;
}

// @public
export class ActivityHandler extends ActivityHandlerBase {
    protected static createInvokeResponse(body?: any): InvokeResponse;
    protected defaultNextEvent(context: TurnContext): () => Promise<void>;
    protected dispatchConversationUpdateActivity(context: TurnContext): Promise<void>;
    protected dispatchEventActivity(context: TurnContext): Promise<void>;
    protected dispatchInstallationUpdateActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageDeleteActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageReactionActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageUpdateActivity(context: TurnContext): Promise<void>;
    protected handle(context: TurnContext, type: string, onNext: () => Promise<void>): Promise<any>;
    // (undocumented)
    protected readonly handlers: {
        [type: string]: BotHandler[];
    };
    protected on(type: string, handler: BotHandler): this;
    protected onAdaptiveCardInvoke(_context: TurnContext, _invokeValue: AdaptiveCardInvokeValue): Promise<AdaptiveCardInvokeResponse>;
    onCommand(handler: BotHandler): this;
    protected onCommandActivity(context: TurnContext): Promise<void>;
    onCommandResult(handler: BotHandler): this;
    protected onCommandResultActivity(context: TurnContext): Promise<void>;
    onConversationUpdate(handler: BotHandler): this;
    protected onConversationUpdateActivity(context: TurnContext): Promise<void>;
    onDialog(handler: BotHandler): this;
    onEndOfConversation(handler: BotHandler): this;
    protected onEndOfConversationActivity(context: TurnContext): Promise<void>;
    onEvent(handler: BotHandler): this;
    protected onEventActivity(context: TurnContext): Promise<void>;
    onInstallationUpdate(handler: BotHandler): this;
    protected onInstallationUpdateActivity(context: TurnContext): Promise<void>;
    onInstallationUpdateAdd(handler: BotHandler): this;
    protected onInstallationUpdateAddActivity(context: TurnContext): Promise<void>;
    onInstallationUpdateRemove(handler: BotHandler): this;
    protected onInstallationUpdateRemoveActivity(context: TurnContext): Promise<void>;
    protected onInvokeActivity(context: TurnContext): Promise<InvokeResponse>;
    onMembersAdded(handler: BotHandler): this;
    onMembersRemoved(handler: BotHandler): this;
    onMessage(handler: BotHandler): this;
    protected onMessageActivity(context: TurnContext): Promise<void>;
    onMessageDelete(handler: BotHandler): this;
    protected onMessageDeleteActivity(context: TurnContext): Promise<void>;
    onMessageReaction(handler: BotHandler): this;
    protected onMessageReactionActivity(context: TurnContext): Promise<void>;
    onMessageUpdate(handler: BotHandler): this;
    protected onMessageUpdateActivity(context: TurnContext): Promise<void>;
    onReactionsAdded(handler: BotHandler): this;
    protected onReactionsAddedActivity(reactionsAdded: MessageReaction[], context: TurnContext): Promise<void>;
    onReactionsRemoved(handler: BotHandler): this;
    protected onReactionsRemovedActivity(reactionsRemoved: MessageReaction[], context: TurnContext): Promise<void>;
    protected onSearchInvoke(_context: TurnContext, _invokeValue: SearchInvokeValue): Promise<SearchInvokeResponse>;
    protected onSignInInvoke(_context: TurnContext): Promise<void>;
    onTokenResponseEvent(handler: BotHandler): this;
    onTurn(handler: BotHandler): this;
    protected onTurnActivity(context: TurnContext): Promise<void>;
    onTyping(handler: BotHandler): this;
    protected onTypingActivity(context: TurnContext): Promise<void>;
    protected onUnrecognizedActivity(context: TurnContext): Promise<void>;
    onUnrecognizedActivityType(handler: BotHandler): this;
    run(context: TurnContext): Promise<void>;
}

// @public
export class ActivityHandlerBase {
    protected onCommandActivity(_context: TurnContext): Promise<void>;
    protected onCommandResultActivity(_context: TurnContext): Promise<void>;
    protected onConversationUpdateActivity(context: TurnContext): Promise<void>;
    protected onEndOfConversationActivity(_context: TurnContext): Promise<void>;
    protected onEventActivity(_context: TurnContext): Promise<void>;
    protected onInstallationUpdateActivity(context: TurnContext): Promise<void>;
    protected onInstallationUpdateAddActivity(_context: TurnContext): Promise<void>;
    protected onInstallationUpdateRemoveActivity(_context: TurnContext): Promise<void>;
    protected onInvokeActivity(_context: TurnContext): Promise<InvokeResponse>;
    protected onMembersAddedActivity(_membersAdded: ChannelAccount[], _context: TurnContext): Promise<void>;
    protected onMembersRemovedActivity(_membersRemoved: ChannelAccount[], _context: TurnContext): Promise<void>;
    protected onMessageActivity(_context: TurnContext): Promise<void>;
    protected onMessageDeleteActivity(_context: TurnContext): Promise<void>;
    protected onMessageReactionActivity(context: TurnContext): Promise<void>;
    protected onMessageUpdateActivity(_context: TurnContext): Promise<void>;
    protected onReactionsAddedActivity(_reactionsAdded: MessageReaction[], _context: TurnContext): Promise<void>;
    protected onReactionsRemovedActivity(_reactionsRemoved: MessageReaction[], _context: TurnContext): Promise<void>;
    protected onTurnActivity(context: TurnContext): Promise<void>;
    protected onTypingActivity(_context: TurnContext): Promise<void>;
    protected onUnrecognizedActivity(_context: TurnContext): Promise<void>;
    run(context: TurnContext): Promise<void>;
}

// Warning: (ae-internal-missing-underscore) The name "assertBotComponent" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export function assertBotComponent(val: unknown, ..._args: unknown[]): asserts val is BotComponent;

// Warning: (ae-internal-missing-underscore) The name "assertStoreItems" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal @deprecated (undocumented)
export function assertStoreItems(val: unknown, ..._args: unknown[]): asserts val is StoreItem;

// @public
export class AutoSaveStateMiddleware implements Middleware {
    constructor(...botStates: BotState[]);
    add(...botStates: BotState[]): this;
    botStateSet: BotStateSet;
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export abstract class BotAdapter {
    // (undocumented)
    readonly BotIdentityKey: symbol;
    // (undocumented)
    readonly ConnectorClientKey: symbol;
    abstract continueConversation(reference: Partial<ConversationReference>, logic: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    continueConversationAsync(botAppId: string, reference: Partial<ConversationReference>, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    continueConversationAsync(claimsIdentity: ClaimsIdentity, reference: Partial<ConversationReference>, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    continueConversationAsync(claimsIdentity: ClaimsIdentity, reference: Partial<ConversationReference>, audience: string, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    createConversationAsync(_botAppId: string, _channelId: string, _serviceUrl: string, _audience: string, _conversationParameters: ConversationParameters, _logic: (context: TurnContext) => Promise<void>): Promise<void>;
    abstract deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    // (undocumented)
    protected middleware: MiddlewareSet;
    // (undocumented)
    readonly OAuthScopeKey: symbol;
    get onTurnError(): (context: TurnContext, error: Error) => Promise<void>;
    // Warning: (ae-setter-with-docs) The doc comment for the property "onTurnError" must appear on the getter, not the setter.
    set onTurnError(value: (context: TurnContext, error: Error) => Promise<void>);
    protected runMiddleware(context: TurnContext, next: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    abstract sendActivities(context: TurnContext, activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    abstract updateActivity(context: TurnContext, activity: Partial<Activity>): Promise<ResourceResponse | void>;
    use(...middlewares: (MiddlewareHandler | Middleware)[]): this;
}

// @public (undocumented)
export const BotCallbackHandlerKey = "botCallbackHandler";

// @public
export abstract class BotComponent {
    // (undocumented)
    abstract configureServices(services: ServiceCollection, configuration: Configuration): void;
    // (undocumented)
    static z: z.ZodType<BotComponent, z.ZodTypeDef, BotComponent>;
}

export { BotFrameworkClient }

// @public
export interface BotFrameworkSkill {
    appId: string;
    id: string;
    skillEndpoint: string;
}

// @public
export type BotHandler = (context: TurnContext, next: () => Promise<void>) => Promise<any>;

// @public (undocumented)
export interface BotPageViewTelemetryClient {
    // (undocumented)
    trackPageView(telemetry: TelemetryPageView): any;
}

// @public
export class BotState implements PropertyManager {
    constructor(storage: Storage_2, storageKey: StorageKeyFactory);
    clear(context: TurnContext): Promise<void>;
    createProperty<T = any>(name: string): StatePropertyAccessor<T>;
    delete(context: TurnContext): Promise<void>;
    get(context: TurnContext): any | undefined;
    load(context: TurnContext, force?: boolean): Promise<any>;
    saveChanges(context: TurnContext, force?: boolean): Promise<void>;
    // (undocumented)
    protected storage: Storage_2;
    // (undocumented)
    protected storageKey: StorageKeyFactory;
}

// @public
export class BotStatePropertyAccessor<T = any> implements StatePropertyAccessor<T> {
    constructor(state: BotState, name: string);
    delete(context: TurnContext): Promise<void>;
    get(context: TurnContext): Promise<T | undefined>;
    // (undocumented)
    get(context: TurnContext, defaultValue: T): Promise<T>;
    // (undocumented)
    readonly name: string;
    set(context: TurnContext, value: T): Promise<void>;
    // (undocumented)
    protected readonly state: BotState;
}

// @public
export class BotStateSet {
    constructor(...botStates: BotState[]);
    add(...botStates: BotState[]): this;
    readonly botStates: BotState[];
    loadAll(context: TurnContext, force?: boolean): Promise<void>;
    saveAllChanges(context: TurnContext, force?: boolean): Promise<void>;
}

// @public (undocumented)
export interface BotTelemetryClient {
    // (undocumented)
    flush(): any;
    // (undocumented)
    trackDependency(telemetry: TelemetryDependency): any;
    // (undocumented)
    trackEvent(telemetry: TelemetryEvent): any;
    // (undocumented)
    trackException(telemetry: TelemetryException): any;
    // (undocumented)
    trackTrace(telemetry: TelemetryTrace): any;
}

// @public
export const BotTelemetryClientKey = "BotTelemetryClient";

// @public
export class BrowserLocalStorage extends MemoryStorage {
    constructor();
}

// @public
export class BrowserSessionStorage extends MemoryStorage {
    constructor();
}

// @public
export interface CachedBotState {
    hash: string;
    state: {
        [id: string]: any;
    };
}

// @public
export function calculateChangeHash(item: StoreItem): string;

// @public
export class CardFactory {
    static actions(actions: (CardAction | string)[] | undefined): CardAction[];
    static adaptiveCard(card: any): Attachment;
    static animationCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<AnimationCard>): Attachment;
    static audioCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<AudioCard>): Attachment;
    static contentTypes: any;
    static heroCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Attachment;
    static heroCard(title: string, text: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Attachment;
    static images(images: (CardImage | string)[] | undefined): CardImage[];
    static media(links: (MediaUrl | string)[] | undefined): MediaUrl[];
    static o365ConnectorCard(card: O365ConnectorCard): Attachment;
    static oauthCard(connectionName: string, title: string, text?: string, link?: string, tokenExchangeResource?: TokenExchangeResource, tokenPostResource?: TokenPostResource): Attachment;
    static receiptCard(card: ReceiptCard): Attachment;
    static signinCard(title: string, url: string, text?: string): Attachment;
    static thumbnailCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Attachment;
    static thumbnailCard(title: string, text: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Attachment;
    static videoCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<VideoCard>): Attachment;
}

// @public
export abstract class CloudAdapterBase extends BotAdapter {
    constructor(botFrameworkAuthentication: BotFrameworkAuthentication);
    // (undocumented)
    protected readonly botFrameworkAuthentication: BotFrameworkAuthentication;
    // (undocumented)
    readonly ConnectorFactoryKey: symbol;
    // @deprecated (undocumented)
    continueConversation(_reference: Partial<ConversationReference>, _logic: (context: TurnContext) => Promise<void>): Promise<void>;
    // @internal (undocumented)
    continueConversationAsync(botAppIdOrClaimsIdentity: string | ClaimsIdentity, reference: Partial<ConversationReference>, logicOrAudience: ((context: TurnContext) => Promise<void>) | string, maybeLogic?: (context: TurnContext) => Promise<void>): Promise<void>;
    protected createClaimsIdentity(botAppId?: string): ClaimsIdentity;
    // (undocumented)
    createConversationAsync(botAppId: string, channelId: string, serviceUrl: string, audience: string, conversationParameters: ConversationParameters, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    // (undocumented)
    deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    protected processActivity(authHeader: string, activity: Activity, logic: (context: TurnContext) => Promise<void>): Promise<InvokeResponse | undefined>;
    protected processActivity(authenticateRequestResult: AuthenticateRequestResult, activity: Activity, logic: (context: TurnContext) => Promise<void>): Promise<InvokeResponse | undefined>;
    protected processProactive(claimsIdentity: ClaimsIdentity, continuationActivity: Partial<Activity>, audience: string | undefined, logic: (context: TurnContext) => Promise<void>): Promise<void>;
    // (undocumented)
    sendActivities(context: TurnContext, activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    // (undocumented)
    updateActivity(context: TurnContext, activity: Partial<Activity>): Promise<ResourceResponse | void>;
    // (undocumented)
    readonly UserTokenClientKey: symbol;
}

// @public
export class ComponentRegistration {
    static add(componentRegistration: ComponentRegistration): void;
    static get components(): ComponentRegistration[];
}

// @public
export class ConfigurationBotFrameworkAuthentication extends BotFrameworkAuthentication {
    constructor(botFrameworkAuthConfig?: ConfigurationBotFrameworkAuthenticationOptions, credentialsFactory?: ServiceClientCredentialsFactory, authConfiguration?: AuthenticationConfiguration, botFrameworkClientFetch?: (input: RequestInfo, init?: RequestInit) => Promise<Response>, connectorClientOptions?: ConnectorClientOptions);
    authenticateChannelRequest(authHeader: string): Promise<ClaimsIdentity>;
    authenticateRequest(activity: Activity, authHeader: string): Promise<AuthenticateRequestResult>;
    authenticateStreamingRequest(authHeader: string, channelIdHeader: string): Promise<AuthenticateRequestResult>;
    createBotFrameworkClient(): BotFrameworkClient;
    createConnectorFactory(claimsIdentity: ClaimsIdentity): ConnectorFactory;
    createUserTokenClient(claimsIdentity: ClaimsIdentity): Promise<UserTokenClient>;
}

// Warning: (ae-forgotten-export) The symbol "ZodOptions" needs to be exported by the entry point index.d.ts
//
// @public
export interface ConfigurationBotFrameworkAuthenticationOptions extends ZodOptions {
    // (undocumented)
    [key: string]: string | boolean | undefined;
}

// @public
export class ConfigurationServiceClientCredentialFactory extends PasswordServiceClientCredentialFactory {
    constructor(factoryOptions?: ConfigurationServiceClientCredentialFactoryOptions);
    // (undocumented)
    createCredentials(microsoftAppId: string, audience: string, loginEndpoint: string, validateAuthority: boolean): Promise<ServiceClientCredentials>;
    // (undocumented)
    isAuthenticationDisabled(): Promise<boolean>;
    // (undocumented)
    isValidAppId(microsoftAppId: string): Promise<boolean>;
}

// Warning: (ae-forgotten-export) The symbol "TypedConfig" needs to be exported by the entry point index.d.ts
//
// @public
export type ConfigurationServiceClientCredentialFactoryOptions = z.infer<typeof TypedConfig>;

// @public
export class ConsoleTranscriptLogger implements TranscriptLogger {
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export class ConversationState extends BotState {
    constructor(storage: Storage_2, namespace?: string);
    getStorageKey(context: TurnContext): string | undefined;
}

// @public
export interface CoreAppCredentials {
    // Warning: (ae-forgotten-export) The symbol "CoreWebResource" needs to be exported by the entry point index.d.ts
    signRequest(webResource: CoreWebResource): Promise<CoreWebResource>;
}

// @public
export function createBotFrameworkAuthenticationFromConfiguration(configuration: Configuration | null, credentialsFactory?: ServiceClientCredentialsFactory, authConfiguration?: AuthenticationConfiguration, botFrameworkClientFetch?: (input: RequestInfo, init?: RequestInit) => Promise<Response>, connectorClientOptions?: ConnectorClientOptions): BotFrameworkAuthentication;

// @public
export function createServiceClientCredentialFactoryFromConfiguration(configuration: Configuration): ConfigurationServiceClientCredentialFactory;

// @public
export type DeleteActivityHandler = (context: TurnContext, reference: Partial<ConversationReference>, next: () => Promise<void>) => Promise<void>;

// @public @deprecated
export interface ExtendedUserTokenProvider extends IUserTokenProvider {
    exchangeToken(context: TurnContext, connectionName: string, userId: string, tokenExchangeRequest: TokenExchangeRequest): Promise<TokenResponse>;
    exchangeToken(context: TurnContext, connectionName: string, userId: string, tokenExchangeRequest: TokenExchangeRequest, appCredentials: CoreAppCredentials): Promise<TokenResponse>;
    getAadTokens(context: TurnContext, connectionName: string, resourceUrls: string[], appCredentials?: CoreAppCredentials): Promise<{
        [propertyName: string]: TokenResponse;
    }>;
    getSignInLink(context: TurnContext, connectionName: string, appCredentials?: CoreAppCredentials): Promise<string>;
    getSignInResource(context: TurnContext, connectionName: string): Promise<SignInUrlResponse>;
    getSignInResource(context: TurnContext, connectionName: string, userId: string, finalRedirect?: string): Promise<SignInUrlResponse>;
    getSignInResource(context: TurnContext, connectionName: string, userId: string, finalRedirect?: string, appCredentials?: CoreAppCredentials): Promise<SignInUrlResponse>;
    getUserToken(context: TurnContext, connectionName: string, magicCode?: string, appCredentials?: CoreAppCredentials): Promise<TokenResponse>;
    signOutUser(context: TurnContext, connectionName: string, userId?: string, appCredentials?: CoreAppCredentials): Promise<void>;
}

// @public (undocumented)
export const getTopScoringIntent: (result: RecognizerResult) => {
    intent: string;
    score: number;
};

// @public
export interface IntentScore {
    [key: string]: unknown;
    score?: number;
}

// @public (undocumented)
export const INVOKE_RESPONSE_KEY: unique symbol;

// @public
export class InvokeException<T = unknown> extends Error {
    constructor(status: StatusCodes, response?: T);
    createInvokeResponse(): InvokeResponse;
}

export { InvokeResponse }

// @public @deprecated
export interface IUserTokenProvider {
    getAadTokens(context: TurnContext, connectionName: string, resourceUrls: string[]): Promise<{
        [propertyName: string]: TokenResponse;
    }>;
    getSignInLink(context: TurnContext, connectionName: string): Promise<string>;
    getTokenStatus(context: TurnContext, userId: string, includeFilter?: string, oAuthAppCredentials?: any): Promise<any[]>;
    getUserToken(context: TurnContext, connectionName: string, magicCode?: string): Promise<TokenResponse>;
    signOutUser(context: TurnContext, connectionName: string, userId?: string): Promise<void>;
}

// @public
export class MemoryStorage implements Storage_2 {
    constructor(memory?: {
        [k: string]: string;
    });
    delete(keys: string[]): Promise<void>;
    // (undocumented)
    protected etag: number;
    // (undocumented)
    protected memory: {
        [k: string]: string;
    };
    read(keys: string[]): Promise<StoreItems>;
    write(changes: StoreItems): Promise<void>;
}

// @public
export class MemoryTranscriptStore implements TranscriptStore {
    deleteTranscript(channelId: string, conversationId: string): Promise<void>;
    getTranscriptActivities(channelId: string, conversationId: string, continuationToken?: string, startDate?: Date): Promise<PagedResult<Activity>>;
    listTranscripts(channelId: string, continuationToken?: string): Promise<PagedResult<TranscriptInfo>>;
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export class MessageFactory {
    static attachment(attachment: Attachment, text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static carousel(attachments: Attachment[], text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static contentUrl(url: string, contentType: string, name?: string, text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static list(attachments: Attachment[], text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static suggestedActions(actions: (CardAction | string)[], text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static text(text: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
}

// @public
export interface Middleware {
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export type MiddlewareHandler = (context: TurnContext, next: () => Promise<void>) => Promise<void>;

// @public
export class MiddlewareSet implements Middleware {
    constructor(...middlewares: (MiddlewareHandler | Middleware)[]);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    run(context: TurnContext, next: () => Promise<void>): Promise<void>;
    use(...middlewares: (MiddlewareHandler | Middleware)[]): this;
}

// @public
export class NullTelemetryClient implements BotTelemetryClient, BotPageViewTelemetryClient {
    constructor(_settings?: any);
    flush(): void;
    trackDependency(_telemetry: TelemetryDependency): void;
    trackEvent(_telemetry: TelemetryEvent): void;
    trackException(_telemetry: TelemetryException): void;
    trackPageView(_telemetry: TelemetryPageView): void;
    trackTrace(_telemetry: TelemetryTrace): void;
}

// @public
export const OAuthLoginTimeoutKey = "loginTimeout";

// @public
export const OAuthLoginTimeoutMsValue = 900000;

// @public
export interface PagedResult<T> {
    continuationToken: string;
    items: T[];
}

// @public
export class PrivateConversationState extends BotState {
    constructor(storage: Storage_2, namespace?: string);
    getStorageKey(context: TurnContext): string | undefined;
}

// @public
export interface PropertyManager {
    createProperty<T = any>(name: string): StatePropertyAccessor<T>;
}

// @public
export abstract class QueueStorage {
    abstract queueActivity(activity: Partial<Activity>, visibilityTimeout?: number, timeToLive?: number): Promise<string>;
}

// @public
export interface RecognizerResult {
    [propName: string]: any;
    alteredText?: string;
    entities?: any;
    intents: Record<string, IntentScore>;
    text: string;
}

// @public
export class RegisterClassMiddleware<T> implements Middleware {
    constructor(service: T, key: string | symbol);
    onTurn(turnContext: TurnContext, next: () => Promise<void>): Promise<void>;
    service: T;
}

// @public
export type SendActivitiesHandler = (context: TurnContext, activities: Partial<Activity>[], next: () => Promise<ResourceResponse[]>) => Promise<ResourceResponse[]>;

// @public
export enum Severity {
    // (undocumented)
    Critical = 4,
    // (undocumented)
    Error = 3,
    // (undocumented)
    Information = 1,
    // (undocumented)
    Verbose = 0,
    // (undocumented)
    Warning = 2
}

// @public (undocumented)
export const sharePointTokenExchange = "cardExtension/token";

// @public
export class ShowTypingMiddleware implements Middleware {
    constructor(delay?: number, period?: number);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export class SkillConversationIdFactory extends SkillConversationIdFactoryBase {
    constructor(storage: Storage_2);
    createSkillConversationIdWithOptions(options: SkillConversationIdFactoryOptions): Promise<string>;
    deleteConversationReference(skillConversationId: string): Promise<void>;
    getSkillConversationReference(skillConversationId: string): Promise<SkillConversationReference>;
}

// @public
export abstract class SkillConversationIdFactoryBase {
    // @deprecated
    createSkillConversationId(_conversationReference: ConversationReference): Promise<string>;
    createSkillConversationIdWithOptions(_options: SkillConversationIdFactoryOptions): Promise<string>;
    abstract deleteConversationReference(skillConversationId: string): Promise<void>;
    // @deprecated
    getConversationReference(_skillConversationId: string): Promise<ConversationReference>;
    getSkillConversationReference(_skillConversationId: string): Promise<SkillConversationReference>;
}

// @public (undocumented)
export interface SkillConversationIdFactoryOptions {
    activity: Activity;
    botFrameworkSkill: BotFrameworkSkill;
    fromBotId: string;
    fromBotOAuthScope: string;
}

// @public (undocumented)
export interface SkillConversationReference {
    // (undocumented)
    conversationReference: ConversationReference;
    // (undocumented)
    oAuthScope: string;
}

// @public
export const SkillConversationReferenceKey: unique symbol;

// @public
export class SkypeMentionNormalizeMiddleware implements Middleware {
    static normalizeSkypeMentionText(activity: Activity): void;
    onTurn(turnContext: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export interface StatePropertyAccessor<T = any> {
    delete(context: TurnContext): Promise<void>;
    get(context: TurnContext): Promise<T | undefined>;
    get(context: TurnContext, defaultValue: T): Promise<T>;
    set(context: TurnContext, value: T): Promise<void>;
}

// @public
interface Storage_2 {
    delete(keys: string[]): Promise<void>;
    read(keys: string[]): Promise<StoreItems>;
    write(changes: StoreItems): Promise<void>;
}
export { Storage_2 as Storage }

// @public
export type StorageKeyFactory = (context: TurnContext) => Promise<string>;

// @public
export interface StoreItem {
    [key: string]: any;
    eTag?: string;
}

// @public
export interface StoreItems {
    [key: string]: any;
}

// @public
export class StringUtils {
    static ellipsis(text: string, length: number): string;
    static ellipsisHash(text: string, length: number): string;
    static hash(text: string): string;
}

// @public (undocumented)
export interface TelemetryDependency {
    // (undocumented)
    data: string;
    // (undocumented)
    dependencyTypeName: string;
    // (undocumented)
    duration: number;
    // (undocumented)
    name: string;
    // (undocumented)
    resultCode: number;
    // (undocumented)
    success: boolean;
    // (undocumented)
    target: string;
}

// @public (undocumented)
export interface TelemetryEvent {
    // (undocumented)
    metrics?: {
        [key: string]: number;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties?: {
        [key: string]: any;
    };
}

// @public (undocumented)
export interface TelemetryException {
    // (undocumented)
    exception: Error;
    // (undocumented)
    handledAt?: string;
    // (undocumented)
    measurements?: {
        [key: string]: number;
    };
    // (undocumented)
    properties?: {
        [key: string]: string;
    };
    // (undocumented)
    severityLevel?: Severity;
}

// @public
export class TelemetryLoggerMiddleware implements Middleware {
    constructor(telemetryClient: BotTelemetryClient, logPersonalInformation?: boolean);
    static readonly botMsgDeleteEvent: string;
    static readonly botMsgReceiveEvent: string;
    static readonly botMsgSendEvent: string;
    static readonly botMsgUpdateEvent: string;
    protected fillDeleteEventProperties(activity: Activity, telemetryProperties?: Record<string, string>): Promise<Record<string, string>>;
    protected fillReceiveEventProperties(activity: Activity, telemetryProperties?: Record<string, string>): Promise<Record<string, string>>;
    protected fillSendEventProperties(activity: Activity, telemetryProperties?: Record<string, string>): Promise<Record<string, string>>;
    protected fillUpdateEventProperties(activity: Activity, telemetryProperties?: Record<string, string>): Promise<Record<string, string>>;
    get logPersonalInformation(): boolean;
    protected onDeleteActivity(activity: Activity): Promise<void>;
    protected onReceiveActivity(activity: Activity): Promise<void>;
    protected onSendActivity(activity: Activity): Promise<void>;
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    protected onUpdateActivity(activity: Activity): Promise<void>;
    get telemetryClient(): BotTelemetryClient;
}

// @public (undocumented)
export interface TelemetryPageView {
    // (undocumented)
    metrics?: {
        [key: string]: number;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties?: {
        [key: string]: string;
    };
}

// @public (undocumented)
export interface TelemetryTrace {
    // (undocumented)
    message: string;
    // (undocumented)
    properties?: {
        [key: string]: string;
    };
    // (undocumented)
    severityLevel?: Severity;
}

// @public
export function telemetryTrackDialogView(telemetryClient: BotTelemetryClient, dialogName: string, properties?: {
    [key: string]: any;
}, metrics?: {
    [key: string]: number;
}): void;

// @public
export type TestActivityInspector = (activity: Partial<Activity>, description?: string) => void;

// @public
export class TestAdapter extends BotAdapter implements ExtendedUserTokenProvider {
    constructor(logicOrConversation?: ((context: TurnContext) => Promise<void>) | ConversationReference, template?: Partial<Activity>, sendTraceActivity?: boolean);
    readonly activeQueue: Partial<Activity>[];
    get activityBuffer(): Partial<Activity>[];
    addExchangeableToken(connectionName: string, channelId: string, userId: string, exchangeableItem: string, token: string): void;
    addUserToken(connectionName: string, channelId: string, userId: string, token: string, magicCode?: string): void;
    continueConversation(_reference: Partial<ConversationReference>, _logic: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    conversation: ConversationReference;
    protected createContext(request: Partial<Activity>): TurnContext;
    static createConversation(name: string, user?: string, bot?: string): ConversationReference;
    deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    get enableTrace(): boolean;
    // Warning: (ae-setter-with-docs) The doc comment for the property "enableTrace" must appear on the getter, not the setter.
    set enableTrace(value: boolean);
    exchangeToken(context: TurnContext, connectionName: string, userId: string, tokenExchangeRequest: TokenExchangeRequest): Promise<TokenResponse>;
    getAadTokens(_context: TurnContext, _connectionName: string, _resourceUrls: string[]): Promise<{
        [propertyName: string]: TokenResponse;
    }>;
    getNextReply(): Partial<Activity>;
    getSignInLink(context: TurnContext, connectionName: string): Promise<string>;
    getSignInResource(context: TurnContext, connectionName: string, userId?: string, _finalRedirect?: string): Promise<SignInUrlResponse>;
    getTokenStatus(context: TurnContext, userId: string, includeFilter?: string, _oAuthAppCredentials?: any): Promise<any[]>;
    getUserToken(context: TurnContext, connectionName: string, magicCode?: string): Promise<TokenResponse>;
    locale: string;
    makeActivity(text?: string): Partial<Activity>;
    processActivity(activity: string | Partial<Activity>, callback?: (context: TurnContext) => Promise<any>): Promise<any>;
    receiveActivity(activity: string | Partial<Activity>): Promise<void>;
    send(userSays: string | Partial<Activity>): TestFlow;
    sendActivities(context: TurnContext, activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    sendTextToBot(userSays: string, callback: (context: TurnContext) => Promise<any>): Promise<any>;
    signOutUser(context: TurnContext, connectionName?: string, userId?: string): Promise<void>;
    readonly template: Partial<Activity>;
    test(userSays: string | Partial<Activity>, expected: string | Partial<Activity> | ((activity: Partial<Activity>, description?: string) => void), description?: string, _timeout?: number): TestFlow;
    testActivities(activities: Partial<Activity>[], description?: string, timeout?: number): TestFlow;
    throwOnExchangeRequest(connectionName: string, channelId: string, userId: string, exchangeableItem: string): void;
    updateActivity(context: TurnContext, activity: Partial<Activity>): Promise<ResourceResponse | void>;
}

// @public
export class TestFlow {
    constructor(previous: Promise<void>, adapter: TestAdapter, callback?: (turnContext: TurnContext) => Promise<unknown>);
    assertNoReply(description?: string, timeout?: number): TestFlow;
    assertReply(expected: string | Partial<Activity> | TestActivityInspector, description?: string, timeout?: number): TestFlow;
    assertReplyOneOf(candidates: string[], description?: string, timeout?: number): TestFlow;
    catch(onRejected?: (reason: any) => void): TestFlow;
    delay(ms: number): TestFlow;
    finally(onFinally: () => void): Promise<void>;
    // (undocumented)
    previous: Promise<void>;
    send(userSays: string | Partial<Activity>): TestFlow;
    sendConversationUpdate(): TestFlow;
    startTest(): Promise<void>;
    test(userSays: string | Partial<Activity>, expected: string | Partial<Activity> | ((activity: Partial<Activity>, description?: string) => void), description?: string, timeout?: number): TestFlow;
    then(onFulfilled?: () => void, onRejected?: (err: any) => void): TestFlow;
}

// @public (undocumented)
export const tokenExchangeOperationName = "signin/tokenExchange";

// @public
export interface TokenPollingSettings {
    interval?: number;
    timeout?: number;
}

// @public
export const TokenPollingSettingsKey = "tokenPollingSettings";

// @public (undocumented)
export const tokenResponseEventName = "tokens/response";

// @public
export interface TranscriptInfo {
    channelId: string;
    created: Date;
    id: string;
}

// @public
export interface TranscriptLogger {
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export class TranscriptLoggerMiddleware implements Middleware {
    constructor(logger: TranscriptLogger);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export interface TranscriptStore extends TranscriptLogger {
    deleteTranscript(channelId: string, conversationId: string): Promise<void>;
    getTranscriptActivities(channelId: string, conversationId: string, continuationToken?: string, startDate?: Date): Promise<PagedResult<Activity>>;
    listTranscripts(channelId: string, continuationToken?: string): Promise<PagedResult<TranscriptInfo>>;
}

// @public (undocumented)
export interface TurnContext {
}

// @public
export class TurnContext {
    constructor(adapterOrContext: BotAdapter, request: Partial<Activity>);
    constructor(adapterOrContext: TurnContext);
    get activity(): Activity;
    get adapter(): BotAdapter;
    static applyConversationReference(activity: Partial<Activity>, reference: Partial<ConversationReference>, isIncoming?: boolean): Partial<Activity>;
    readonly bufferedReplyActivities: Partial<Activity>[];
    protected copyTo(context: TurnContext): void;
    deleteActivity(idOrReference: string | Partial<ConversationReference>): Promise<void>;
    static getConversationReference(activity: Partial<Activity>): Partial<ConversationReference>;
    static getMentions(activity: Partial<Activity>): Mention[];
    static getReplyConversationReference(activity: Partial<Activity>, reply: ResourceResponse): Partial<ConversationReference>;
    get locale(): string | undefined;
    // Warning: (ae-setter-with-docs) The doc comment for the property "locale" must appear on the getter, not the setter.
    set locale(value: string | undefined);
    onDeleteActivity(handler: DeleteActivityHandler): this;
    onSendActivities(handler: SendActivitiesHandler): this;
    onUpdateActivity(handler: UpdateActivityHandler): this;
    static removeMentionText(activity: Partial<Activity>, id: string): string;
    static removeRecipientMention(activity: Partial<Activity>): string;
    get responded(): boolean;
    // Warning: (ae-setter-with-docs) The doc comment for the property "responded" must appear on the getter, not the setter.
    set responded(value: boolean);
    sendActivities(activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    sendActivity(activityOrText: string | Partial<Activity>, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    sendTraceActivity(name: string, value?: any, valueType?: string, label?: string): Promise<ResourceResponse | undefined>;
    get turnState(): TurnContextStateCollection;
    updateActivity(activity: Partial<Activity>): Promise<ResourceResponse | void>;
}

// @public
export class TurnContextStateCollection extends Map<any, any> {
    get<T = any>(key: any): T;
    get(key: any): any;
    pop(key: any): any;
    push(key: any, value: any): void;
}

// @public
export type UpdateActivityHandler = (context: TurnContext, activity: Partial<Activity>, next: () => Promise<void>) => Promise<void>;

// @public
export function useBotState(botAdapter: BotAdapter, ...botStates: BotState[]): BotAdapter;

// @public
export class UserState extends BotState {
    constructor(storage: Storage_2, namespace?: string);
    getStorageKey(context: TurnContext): string | undefined;
}

// @public
export const verifyStateOperationName = "signin/verifyState";


export * from "botframework-schema";

// (No @packageDocumentation comment for this package)

```
