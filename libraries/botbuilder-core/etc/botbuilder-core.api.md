## API Report File for "botbuilder-core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from 'botframework-schema';
import { AnimationCard } from 'botframework-schema';
import { Attachment } from 'botframework-schema';
import { AudioCard } from 'botframework-schema';
import { CardAction } from 'botframework-schema';
import { CardImage } from 'botframework-schema';
import { ChannelAccount } from 'botframework-schema';
import { ConversationReference } from 'botframework-schema';
import { HeroCard } from 'botframework-schema';
import { InputHints } from 'botframework-schema';
import { MediaUrl } from 'botframework-schema';
import { Mention } from 'botframework-schema';
import { MessageReaction } from 'botframework-schema';
import { O365ConnectorCard } from 'botframework-schema';
import { ReceiptCard } from 'botframework-schema';
import { ResourceResponse } from 'botframework-schema';
import { SignInUrlResponse } from 'botframework-schema';
import { ThumbnailCard } from 'botframework-schema';
import { TokenExchangeRequest } from 'botframework-schema';
import { TokenExchangeResource } from 'botframework-schema';
import { TokenResponse } from 'botframework-schema';
import { VideoCard } from 'botframework-schema';

// @public
export class ActivityFactory {
    static checkLGResult(lgResult: any): string[];
    static fromObject(lgResult: any): Partial<Activity>;
    }

// @public
export class ActivityHandler extends ActivityHandlerBase {
    protected defaultNextEvent(context: TurnContext): () => Promise<void>;
    protected dispatchConversationUpdateActivity(context: TurnContext): Promise<void>;
    protected dispatchEventActivity(context: TurnContext): Promise<void>;
    protected dispatchMessageReactionActivity(context: TurnContext): Promise<void>;
    protected handle(context: TurnContext, type: string, onNext: () => Promise<void>): Promise<any>;
    // (undocumented)
    protected readonly handlers: {
        [type: string]: BotHandler[];
    };
    protected on(type: string, handler: BotHandler): this;
    onConversationUpdate(handler: BotHandler): this;
    protected onConversationUpdateActivity(context: TurnContext): Promise<void>;
    onDialog(handler: BotHandler): this;
    onEndOfConversation(handler: BotHandler): this;
    protected onEndOfConversationActivity(context: TurnContext): Promise<void>;
    onEvent(handler: BotHandler): this;
    protected onEventActivity(context: TurnContext): Promise<void>;
    // (undocumented)
    protected onInvokeActivity(context: TurnContext): Promise<InvokeResponse>;
    onMembersAdded(handler: BotHandler): this;
    onMembersRemoved(handler: BotHandler): this;
    onMessage(handler: BotHandler): this;
    protected onMessageActivity(context: TurnContext): Promise<void>;
    onMessageReaction(handler: BotHandler): this;
    protected onMessageReactionActivity(context: TurnContext): Promise<void>;
    onReactionsAdded(handler: BotHandler): this;
    protected onReactionsAddedActivity(reactionsAdded: MessageReaction[], context: TurnContext): Promise<void>;
    onReactionsRemoved(handler: BotHandler): this;
    protected onReactionsRemovedActivity(reactionsRemoved: MessageReaction[], context: TurnContext): Promise<void>;
    // (undocumented)
    protected onSignInInvoke(context: TurnContext): Promise<void>;
    onTokenResponseEvent(handler: BotHandler): this;
    onTurn(handler: BotHandler): this;
    protected onTurnActivity(context: TurnContext): Promise<void>;
    onTyping(handler: BotHandler): this;
    protected onTypingActivity(context: TurnContext): Promise<void>;
    protected onUnrecognizedActivity(context: TurnContext): Promise<void>;
    onUnrecognizedActivityType(handler: BotHandler): this;
    run(context: TurnContext): Promise<void>;
}

// @public
export class ActivityHandlerBase {
    protected onConversationUpdateActivity(context: TurnContext): Promise<void>;
    protected onEndOfConversationActivity(context: TurnContext): Promise<void>;
    protected onEventActivity(context: TurnContext): Promise<void>;
    protected onInvokeActivity(context: TurnContext): Promise<InvokeResponse>;
    protected onMembersAddedActivity(membersAdded: ChannelAccount[], context: TurnContext): Promise<void>;
    protected onMembersRemovedActivity(membersRemoved: ChannelAccount[], context: TurnContext): Promise<void>;
    protected onMessageActivity(context: TurnContext): Promise<void>;
    protected onMessageReactionActivity(context: TurnContext): Promise<void>;
    protected onReactionsAddedActivity(reactionsAdded: MessageReaction[], context: TurnContext): Promise<void>;
    protected onReactionsRemovedActivity(reactionsRemoved: MessageReaction[], context: TurnContext): Promise<void>;
    protected onTurnActivity(context: TurnContext): Promise<void>;
    protected onTypingActivity(context: TurnContext): Promise<void>;
    protected onUnrecognizedActivity(context: TurnContext): Promise<void>;
    run(context: TurnContext): Promise<void>;
}

// @public
export class AutoSaveStateMiddleware implements Middleware {
    constructor(...botStates: BotState[]);
    add(...botStates: BotState[]): this;
    botStateSet: BotStateSet;
    // (undocumented)
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export abstract class BotAdapter {
    // (undocumented)
    readonly BotIdentityKey: Symbol;
    abstract continueConversation(reference: Partial<ConversationReference>, logic: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    abstract deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    // (undocumented)
    protected middleware: MiddlewareSet;
    // (undocumented)
    readonly OAuthScopeKey: Symbol;
    onTurnError: (context: TurnContext, error: Error) => Promise<void>;
    protected runMiddleware(context: TurnContext, next: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    abstract sendActivities(context: TurnContext, activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    abstract updateActivity(context: TurnContext, activity: Partial<Activity>): Promise<void>;
    use(...middleware: (MiddlewareHandler | Middleware)[]): this;
}

// @public (undocumented)
export const BotCallbackHandlerKey = "botCallbackHandler";

// @public (undocumented)
export interface BotFrameworkClient {
    postActivity: (<T>(fromBotId: string, toBotId: string, toUrl: string, serviceUrl: string, conversationId: string, activity: Activity) => Promise<InvokeResponse<T>>) | ((fromBotId: string, toBotId: string, toUrl: string, serviceUrl: string, conversationId: string, activity: Activity) => Promise<InvokeResponse>);
}

// @public
export interface BotFrameworkSkill {
    appId: string;
    id: string;
    skillEndpoint: string;
}

// @public
export type BotHandler = (context: TurnContext, next: () => Promise<void>) => Promise<any>;

// @public
export class BotState implements PropertyManager {
    constructor(storage: Storage, storageKey: StorageKeyFactory);
    clear(context: TurnContext): Promise<void>;
    createProperty<T = any>(name: string): StatePropertyAccessor<T>;
    delete(context: TurnContext): Promise<void>;
    get(context: TurnContext): any | undefined;
    load(context: TurnContext, force?: boolean): Promise<any>;
    saveChanges(context: TurnContext, force?: boolean): Promise<void>;
    // (undocumented)
    protected storage: Storage;
    // (undocumented)
    protected storageKey: StorageKeyFactory;
}

// @public
export class BotStatePropertyAccessor<T = any> implements StatePropertyAccessor<T> {
    constructor(state: BotState, name: string);
    // (undocumented)
    delete(context: TurnContext): Promise<void>;
    // (undocumented)
    get(context: TurnContext): Promise<T | undefined>;
    // (undocumented)
    get(context: TurnContext, defaultValue: T): Promise<T>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    set(context: TurnContext, value: T): Promise<void>;
    // (undocumented)
    protected readonly state: BotState;
}

// @public
export class BotStateSet {
    constructor(...botStates: BotState[]);
    add(...botStates: BotState[]): this;
    readonly botStates: BotState[];
    loadAll(context: TurnContext, force?: boolean): Promise<void>;
    saveAllChanges(context: TurnContext, force?: boolean): Promise<void>;
}

// @public (undocumented)
export interface BotTelemetryClient {
    // (undocumented)
    flush(): any;
    // (undocumented)
    trackDependency(telemetry: TelemetryDependency): any;
    // (undocumented)
    trackEvent(telemetry: TelemetryEvent): any;
    // (undocumented)
    trackException(telemetry: TelemetryException): any;
    // (undocumented)
    trackTrace(telemetry: TelemetryTrace): any;
}

// @public
export class BrowserLocalStorage extends MemoryStorage {
    constructor();
}

// @public
export class BrowserSessionStorage extends MemoryStorage {
    constructor();
}

// @public
export interface CachedBotState {
    hash: string;
    state: {
        [id: string]: any;
    };
}

// @public
export function calculateChangeHash(item: StoreItem): string;

// @public
export class CardFactory {
    static actions(actions: (CardAction | string)[] | undefined): CardAction[];
    static adaptiveCard(card: any): Attachment;
    static animationCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<AnimationCard>): Attachment;
    static audioCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<AudioCard>): Attachment;
    static contentTypes: any;
    static heroCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Attachment;
    // (undocumented)
    static heroCard(title: string, text: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<HeroCard>): Attachment;
    static images(images: (CardImage | string)[] | undefined): CardImage[];
    static media(links: (MediaUrl | string)[] | undefined): MediaUrl[];
    static o365ConnectorCard(card: O365ConnectorCard): Attachment;
    static oauthCard(connectionName: string, title: string, text?: string, link?: string, tokenExchangeResource?: TokenExchangeResource): Attachment;
    static receiptCard(card: ReceiptCard): Attachment;
    static signinCard(title: string, url: string, text?: string): Attachment;
    static thumbnailCard(title: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Attachment;
    // (undocumented)
    static thumbnailCard(title: string, text: string, images?: (CardImage | string)[], buttons?: (CardAction | string)[], other?: Partial<ThumbnailCard>): Attachment;
    static videoCard(title: string, media: (MediaUrl | string)[], buttons?: (CardAction | string)[], other?: Partial<VideoCard>): Attachment;
}

// @public
export class ConsoleTranscriptLogger implements TranscriptLogger {
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export class ConversationState extends BotState {
    constructor(storage: Storage, namespace?: string);
    getStorageKey(context: TurnContext): string | undefined;
    }

// @public
export interface CoreAppCredentials {
    // Warning: (ae-forgotten-export) The symbol "CoreWebResource" needs to be exported by the entry point index.d.ts
    signRequest(webResource: CoreWebResource): Promise<CoreWebResource>;
}

// @public
export type DeleteActivityHandler = (context: TurnContext, reference: Partial<ConversationReference>, next: () => Promise<void>) => Promise<void>;

// @public
export interface ExtendedUserTokenProvider extends IUserTokenProvider {
    exchangeToken(context: TurnContext, connectionName: string, userId: string, tokenExchangeRequest: TokenExchangeRequest): Promise<TokenResponse>;
    exchangeToken(context: TurnContext, connectionName: string, userId: string, tokenExchangeRequest: TokenExchangeRequest, appCredentials: CoreAppCredentials): Promise<TokenResponse>;
    getAadTokens(context: TurnContext, connectionName: string, resourceUrls: string[], appCredentials?: CoreAppCredentials): Promise<{
        [propertyName: string]: TokenResponse;
    }>;
    getSignInLink(context: TurnContext, connectionName: string, appCredentials?: CoreAppCredentials): Promise<string>;
    getSignInResource(context: TurnContext, connectionName: string): Promise<SignInUrlResponse>;
    getSignInResource(context: TurnContext, connectionName: string, userId: string, finalRedirect?: string): Promise<SignInUrlResponse>;
    getSignInResource(context: TurnContext, connectionName: string, userId: string, finalRedirect?: string, appCredentials?: CoreAppCredentials): Promise<SignInUrlResponse>;
    getUserToken(context: TurnContext, connectionName: string, magicCode?: string, appCredentials?: CoreAppCredentials): Promise<TokenResponse>;
    signOutUser(context: TurnContext, connectionName: string, userId?: string, appCredentials?: CoreAppCredentials): Promise<void>;
}

// @public (undocumented)
export const INVOKE_RESPONSE_KEY: symbol;

// @public
export interface InvokeResponse<T = any> {
    body?: T;
    status: number;
}

// @public
export interface IUserTokenProvider {
    getAadTokens(context: TurnContext, connectionName: string, resourceUrls: string[]): Promise<{
        [propertyName: string]: TokenResponse;
    }>;
    getSignInLink(context: TurnContext, connectionName: string): Promise<string>;
    getUserToken(context: TurnContext, connectionName: string, magicCode?: string): Promise<TokenResponse>;
    signOutUser(context: TurnContext, connectionName: string, userId?: string): Promise<void>;
}

// @public
export class MemoryStorage implements Storage {
    constructor(memory?: {
        [k: string]: string;
    });
    // (undocumented)
    delete(keys: string[]): Promise<void>;
    // (undocumented)
    protected etag: number;
    // (undocumented)
    protected memory: {
        [k: string]: string;
    };
    // (undocumented)
    read(keys: string[]): Promise<StoreItems>;
    // (undocumented)
    write(changes: StoreItems): Promise<void>;
}

// @public
export class MemoryTranscriptStore implements TranscriptStore {
    deleteTranscript(channelId: string, conversationId: string): Promise<void>;
    getTranscriptActivities(channelId: string, conversationId: string, continuationToken?: string, startDate?: Date): Promise<PagedResult<Activity>>;
    listTranscripts(channelId: string, continuationToken?: string): Promise<PagedResult<TranscriptInfo>>;
    logActivity(activity: Activity): void | Promise<void>;
    }

// @public
export class MessageFactory {
    static attachment(attachment: Attachment, text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static carousel(attachments: Attachment[], text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static contentUrl(url: string, contentType: string, name?: string, text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static list(attachments: Attachment[], text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static suggestedActions(actions: (CardAction | string)[], text?: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
    static text(text: string, speak?: string, inputHint?: InputHints | string): Partial<Activity>;
}

// @public
export interface Middleware {
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export type MiddlewareHandler = (context: TurnContext, next: () => Promise<void>) => Promise<void>;

// @public
export class MiddlewareSet implements Middleware {
    constructor(...middleware: (MiddlewareHandler | Middleware)[]);
    // (undocumented)
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    run(context: TurnContext, next: () => Promise<void>): Promise<void>;
    use(...middleware: (MiddlewareHandler | Middleware)[]): this;
}

// @public (undocumented)
export class NullTelemetryClient implements BotTelemetryClient {
    constructor(settings?: any);
    // (undocumented)
    flush(): void;
    // (undocumented)
    trackDependency(telemetry: TelemetryDependency): void;
    // (undocumented)
    trackEvent(telemetry: TelemetryEvent): void;
    // (undocumented)
    trackException(telemetry: TelemetryException): void;
    // (undocumented)
    trackTrace(telemetry: TelemetryTrace): void;
}

// @public
export const OAuthLoginTimeoutKey: string;

// @public
export const OAuthLoginTimeoutMsValue: number;

// @public
export interface PagedResult<T> {
    continuationToken: string;
    items: T[];
}

// @public
export class PrivateConversationState extends BotState {
    constructor(storage: Storage, namespace?: string);
    getStorageKey(context: TurnContext): string | undefined;
    }

// @public
export interface PropertyManager {
    createProperty<T = any>(name: string): StatePropertyAccessor<T>;
}

// @public
export interface RecognizerResult {
    [propName: string]: any;
    readonly alteredText?: string;
    readonly entities?: any;
    readonly intents: {
        [name: string]: {
            score: number;
        };
    };
    readonly text: string;
}

// @public
export type SendActivitiesHandler = (context: TurnContext, activities: Partial<Activity>[], next: () => Promise<ResourceResponse[]>) => Promise<ResourceResponse[]>;

// @public
export enum Severity {
    // (undocumented)
    Critical = 4,
    // (undocumented)
    Error = 3,
    // (undocumented)
    Information = 1,
    // (undocumented)
    Verbose = 0,
    // (undocumented)
    Warning = 2
}

// @public
export class ShowTypingMiddleware implements Middleware {
    constructor(delay?: number, period?: number);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    }

// @public
export abstract class SkillConversationIdFactoryBase {
    // @deprecated
    createSkillConversationId(conversationReference: ConversationReference): Promise<string>;
    createSkillConversationIdWithOptions(options: SkillConversationIdFactoryOptions): Promise<string>;
    abstract deleteConversationReference(skillConversationId: string): Promise<void>;
    // @deprecated
    getConversationReference(skillConversationId: string): Promise<ConversationReference>;
    getSkillConversationReference(skillConversationId: string): Promise<SkillConversationReference>;
}

// @public (undocumented)
export interface SkillConversationIdFactoryOptions {
    activity: Activity;
    botFrameworkSkill: BotFrameworkSkill;
    fromBotId: string;
    fromBotOAuthScope: string;
}

// @public (undocumented)
export interface SkillConversationReference {
    // (undocumented)
    conversationReference: ConversationReference;
    // (undocumented)
    oAuthScope: string;
}

// @public
export class SkypeMentionNormalizeMiddleware implements Middleware {
    // (undocumented)
    static normalizeSkypeMentionText(activity: Activity): void;
    // (undocumented)
    onTurn(turnContext: TurnContext, next: () => Promise<void>): Promise<void>;
}

// @public
export interface StatePropertyAccessor<T = any> {
    delete(context: TurnContext): Promise<void>;
    get(context: TurnContext): Promise<T | undefined>;
    // (undocumented)
    get(context: TurnContext, defaultValue: T): Promise<T>;
    set(context: TurnContext, value: T): Promise<void>;
}

// @public
export enum StatusCodes {
    // (undocumented)
    BAD_GATEWAY = 502,
    // (undocumented)
    BAD_REQUEST = 400,
    // (undocumented)
    CONFLICT = 409,
    // (undocumented)
    INTERNAL_SERVER_ERROR = 500,
    // (undocumented)
    METHOD_NOT_ALLOWED = 405,
    // (undocumented)
    NOT_FOUND = 404,
    // (undocumented)
    NOT_IMPLEMENTED = 501,
    // (undocumented)
    OK = 200,
    // (undocumented)
    UNAUTHORIZED = 401,
    // (undocumented)
    UPGRADE_REQUIRED = 426
}

// @public
export interface Storage {
    delete(keys: string[]): Promise<void>;
    read(keys: string[]): Promise<StoreItems>;
    write(changes: StoreItems): Promise<void>;
}

// @public
export type StorageKeyFactory = (context: TurnContext) => Promise<string>;

// @public
export interface StoreItem {
    [key: string]: any;
    eTag?: string;
}

// @public
export interface StoreItems {
    [key: string]: any;
}

// @public (undocumented)
export interface TelemetryDependency {
    // (undocumented)
    data: string;
    // (undocumented)
    dependencyTypeName: string;
    // (undocumented)
    duration: number;
    // (undocumented)
    name: string;
    // (undocumented)
    resultCode: number;
    // (undocumented)
    success: boolean;
    // (undocumented)
    target: string;
}

// @public (undocumented)
export interface TelemetryEvent {
    // (undocumented)
    metrics?: {
        [key: string]: number;
    };
    // (undocumented)
    name: string;
    // (undocumented)
    properties?: {
        [key: string]: any;
    };
}

// @public (undocumented)
export interface TelemetryException {
    // (undocumented)
    exception: Error;
    // (undocumented)
    handledAt?: string;
    // (undocumented)
    measurements?: {
        [key: string]: number;
    };
    // (undocumented)
    properties?: {
        [key: string]: string;
    };
    // (undocumented)
    severityLevel?: Severity;
}

// @public
export class TelemetryLoggerMiddleware implements Middleware {
    constructor(telemetryClient: BotTelemetryClient, logPersonalInformation?: boolean);
    static readonly botMsgDeleteEvent: string;
    static readonly botMsgReceiveEvent: string;
    static readonly botMsgSendEvent: string;
    static readonly botMsgUpdateEvent: string;
    protected fillDeleteEventProperties(activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }): Promise<{
        [key: string]: string;
    }>;
    protected fillReceiveEventProperties(activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }): Promise<{
        [key: string]: string;
    }>;
    protected fillSendEventProperties(activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }): Promise<{
        [key: string]: string;
    }>;
    protected fillUpdateEventProperties(activity: Activity, telemetryProperties?: {
        [key: string]: string;
    }): Promise<{
        [key: string]: string;
    }>;
    readonly logPersonalInformation: boolean;
    protected onDeleteActivity(activity: Activity): Promise<void>;
    protected onReceiveActivity(activity: Activity): Promise<void>;
    protected onSendActivity(activity: Activity): Promise<void>;
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    protected onUpdateActivity(activity: Activity): Promise<void>;
    readonly telemetryClient: BotTelemetryClient;
    // Warning: (ae-forgotten-export) The symbol "TelemetryConstants" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    readonly telemetryConstants: TelemetryConstants;
}

// @public (undocumented)
export interface TelemetryTrace {
    // (undocumented)
    message: string;
    // (undocumented)
    properties?: {
        [key: string]: string;
    };
    // (undocumented)
    severityLevel?: Severity;
}

// @public
export type TestActivityInspector = (activity: Partial<Activity>, description: string) => void;

// @public
export class TestAdapter extends BotAdapter implements ExtendedUserTokenProvider {
    constructor(logic: (context: TurnContext) => Promise<void>, template?: Partial<Activity>, sendTraceActivities?: boolean);
    readonly activityBuffer: Partial<Activity>[];
    // (undocumented)
    addExchangeableToken(connectionName: string, channelId: string, userId: string, exchangeableItem: string, token: string): void;
    addUserToken(connectionName: string, channelId: string, userId: string, token: string, magicCode?: string): void;
    continueConversation(reference: Partial<ConversationReference>, logic: (revocableContext: TurnContext) => Promise<void>): Promise<void>;
    protected createContext(request: Partial<Activity>): TurnContext;
    deleteActivity(context: TurnContext, reference: Partial<ConversationReference>): Promise<void>;
    readonly deletedActivities: Partial<ConversationReference>[];
    // (undocumented)
    exchangeToken(context: TurnContext, connectionName: string, userId: string, tokenExchangeRequest: TokenExchangeRequest): Promise<TokenResponse>;
    getAadTokens(context: TurnContext, connectionName: string, resourceUrls: string[]): Promise<{
        [propertyName: string]: TokenResponse;
    }>;
    getSignInLink(context: TurnContext, connectionName: string): Promise<string>;
    // (undocumented)
    getSignInResource(context: TurnContext, connectionName: string, userId?: string, finalRedirect?: string): Promise<SignInUrlResponse>;
    getUserToken(context: TurnContext, connectionName: string, magicCode?: string): Promise<TokenResponse>;
    receiveActivity(activity: string | Partial<Activity>): Promise<void>;
    send(userSays: string | Partial<Activity>): TestFlow;
    sendActivities(context: TurnContext, activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    signOutUser(context: TurnContext, connectionName: string): Promise<void>;
    readonly template: Partial<Activity>;
    test(userSays: string | Partial<Activity>, expected: string | Partial<Activity> | ((activity: Partial<Activity>, description?: string) => void), description?: string, timeout?: number): TestFlow;
    testActivities(activities: Partial<Activity>[], description?: string, timeout?: number): TestFlow;
    updateActivity(context: TurnContext, activity: Partial<Activity>): Promise<void>;
    readonly updatedActivities: Partial<Activity>[];
    }

// @public
export class TestFlow {
    constructor(previous: Promise<void>, adapter: TestAdapter);
    assertReply(expected: string | Partial<Activity> | TestActivityInspector, description?: string, timeout?: number): TestFlow;
    assertReplyOneOf(candidates: string[], description?: string, timeout?: number): TestFlow;
    catch(onRejected?: (reason: any) => void): TestFlow;
    delay(ms: number): TestFlow;
    // (undocumented)
    previous: Promise<void>;
    send(userSays: string | Partial<Activity>): TestFlow;
    startTest(): Promise<void>;
    test(userSays: string | Partial<Activity>, expected: string | Partial<Activity> | ((activity: Partial<Activity>, description?: string) => void), description?: string, timeout?: number): TestFlow;
    then(onFulfilled?: () => void): TestFlow;
}

// @public (undocumented)
export const tokenExchangeOperationName: string;

// @public
export interface TokenPollingSettings {
    interval?: number;
    timeout?: number;
}

// @public
export const TokenPollingSettingsKey: string;

// @public (undocumented)
export const tokenResponseEventName: string;

// @public
export interface TranscriptInfo {
    channelId: string;
    created: Date;
    id: string;
}

// @public
export interface TranscriptLogger {
    logActivity(activity: Activity): void | Promise<void>;
}

// @public
export class TranscriptLoggerMiddleware implements Middleware {
    constructor(logger: TranscriptLogger);
    onTurn(context: TurnContext, next: () => Promise<void>): Promise<void>;
    }

// @public
export interface TranscriptStore extends TranscriptLogger {
    deleteTranscript(channelId: string, conversationId: string): Promise<void>;
    getTranscriptActivities(channelId: string, conversationId: string, continuationToken?: string, startDate?: Date): Promise<PagedResult<Activity>>;
    listTranscripts(channelId: string, continuationToken?: string): Promise<PagedResult<TranscriptInfo>>;
}

// @public (undocumented)
export interface TurnContext {
}

// @public
export class TurnContext {
    constructor(adapterOrContext: BotAdapter, request: Partial<Activity>);
    constructor(adapterOrContext: TurnContext);
    readonly activity: Activity;
    readonly adapter: BotAdapter;
    static applyConversationReference(activity: Partial<Activity>, reference: Partial<ConversationReference>, isIncoming?: boolean): Partial<Activity>;
    readonly bufferedReplyActivities: Partial<Activity>[];
    protected copyTo(context: TurnContext): void;
    deleteActivity(idOrReference: string | Partial<ConversationReference>): Promise<void>;
    static getConversationReference(activity: Partial<Activity>): Partial<ConversationReference>;
    static getMentions(activity: Partial<Activity>): Mention[];
    static getReplyConversationReference(activity: Partial<Activity>, reply: ResourceResponse): Partial<ConversationReference>;
    onDeleteActivity(handler: DeleteActivityHandler): this;
    onSendActivities(handler: SendActivitiesHandler): this;
    onUpdateActivity(handler: UpdateActivityHandler): this;
    static removeMentionText(activity: Partial<Activity>, id: string): string;
    static removeRecipientMention(activity: Partial<Activity>): string;
    responded: boolean;
    sendActivities(activities: Partial<Activity>[]): Promise<ResourceResponse[]>;
    sendActivity(activityOrText: string | Partial<Activity>, speak?: string, inputHint?: string): Promise<ResourceResponse | undefined>;
    sendTraceActivity(name: string, value?: any, valueType?: string, label?: string): Promise<ResourceResponse | undefined>;
    readonly turnState: Map<any, any>;
    updateActivity(activity: Partial<Activity>): Promise<void>;
}

// @public
export type UpdateActivityHandler = (context: TurnContext, activity: Partial<Activity>, next: () => Promise<void>) => Promise<void>;

// @public
export class UserState extends BotState {
    constructor(storage: Storage, namespace?: string);
    getStorageKey(context: TurnContext): string | undefined;
    }

// @public
export const verifyStateOperationName: string;


export * from "botframework-schema";

// (No @packageDocumentation comment for this package)

```
