## API Report File for "botbuilder-dialogs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Activity } from 'botbuilder-core';
import { Attachment } from 'botbuilder-core';
import { BotComponent } from 'botbuilder-core';
import { BotFrameworkClient } from 'botbuilder-core';
import { BotFrameworkSkill } from 'botbuilder-core';
import { BotState } from 'botbuilder-core';
import { BotTelemetryClient } from 'botbuilder-core';
import { CardAction } from 'botbuilder-core';
import { Configuration } from 'botbuilder-dialogs-adaptive-runtime-core';
import { ConversationState } from 'botbuilder-core';
import { CoreAppCredentials } from 'botbuilder-core';
import { RecognizerResult } from 'botbuilder-core';
import { ServiceCollection } from 'botbuilder-dialogs-adaptive-runtime-core';
import { SkillConversationIdFactoryBase } from 'botbuilder-core';
import { StatePropertyAccessor } from 'botbuilder-core';
import { TokenResponse } from 'botbuilder-core';
import { TurnContext } from 'botbuilder-core';
import { TurnContextStateCollection } from 'botbuilder-core';
import { UserState } from 'botbuilder-core';

// @public
export class ActivityPrompt extends Dialog {
    constructor(dialogId: string, validator: PromptValidator<Activity>);
    beginDialog(dc: DialogContext, options: PromptOptions): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    protected onPrompt(context: TurnContext, state: object, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: object, options: PromptOptions): Promise<PromptRecognizerResult<Activity>>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    }

// @public
export class AliasPathResolver implements PathResolver {
    constructor(alias: string, prefix: string, postfix?: string);
    transformPath(path: string): string;
}

// @public
export class AtAtPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export class AtPathResolver extends AliasPathResolver {
    constructor();
    transformPath(path: string): string;
}

// @public
export class AttachmentPrompt extends Prompt<Attachment[]> {
    constructor(dialogId: string, validator?: PromptValidator<Attachment[]>);
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: any, options: PromptOptions): Promise<PromptRecognizerResult<Attachment[]>>;
}

// @public
export interface BeginSkillDialogOptions {
    activity: Partial<Activity>;
}

// @public
export class BotStateMemoryScope extends MemoryScope {
    constructor(name: string);
    delete(dc: DialogContext): Promise<void>;
    getMemory(dc: DialogContext): object;
    load(dc: DialogContext, force?: boolean): Promise<void>;
    saveChanges(dc: DialogContext, force?: boolean): Promise<void>;
    setMemory(dc: DialogContext, memory: object): void;
    // (undocumented)
    protected stateKey: string;
}

// @public
export interface Choice {
    action?: CardAction;
    synonyms?: string[];
    value: string;
}

// @public
export class ChoiceFactory {
    static forChannel(channelOrContext: string | TurnContext, choices: (string | Choice)[], text?: string, speak?: string, options?: ChoiceFactoryOptions): Partial<Activity>;
    static heroCard(choices?: (string | Choice)[], text?: string, speak?: string): Activity;
    static inline(choices: (string | Choice)[], text?: string, speak?: string, options?: ChoiceFactoryOptions): Partial<Activity>;
    static list(choices: (string | Choice)[], text?: string, speak?: string, options?: ChoiceFactoryOptions): Partial<Activity>;
    static suggestedAction(choices: (string | Choice)[], text?: string, speak?: string): Partial<Activity>;
    static toChoices(choices: (string | Choice)[] | undefined): Choice[];
}

// @public
export interface ChoiceFactoryOptions {
    includeNumbers?: boolean;
    inlineOr?: string;
    inlineOrMore?: string;
    inlineSeparator?: string;
}

// @public
export class ChoicePrompt extends Prompt<FoundChoice> {
    // Warning: (ae-forgotten-export) The symbol "ChoiceDefaultsChoicePrompt" needs to be exported by the entry point index.d.ts
    constructor(dialogId: string, validator?: PromptValidator<FoundChoice>, defaultLocale?: string, choiceDefaults?: ChoiceDefaultsChoicePrompt);
    choiceOptions: ChoiceFactoryOptions | undefined;
    defaultLocale: string | undefined;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: any, options: PromptOptions): Promise<PromptRecognizerResult<FoundChoice>>;
    recognizerOptions: FindChoicesOptions | undefined;
    style: ListStyle;
}

// @public
export class ClassMemoryScope extends MemoryScope {
    constructor(name?: string);
    getMemory(dc: DialogContext): object;
    protected onFindDialog(dc: DialogContext): Dialog;
}

// @public
export class ComponentDialog<O extends object = {}> extends DialogContainer<O> {
    addDialog(dialog: Dialog): this;
    beginDialog(outerDC: DialogContext, options?: O): Promise<DialogTurnResult>;
    continueDialog(outerDC: DialogContext): Promise<DialogTurnResult>;
    createChildContext(outerDC: DialogContext): DialogContext;
    protected endComponent(outerDC: DialogContext, result: any): Promise<DialogTurnResult>;
    endDialog(context: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    protected initialDialogId: string;
    protected onBeginDialog(innerDC: DialogContext, options?: O): Promise<DialogTurnResult>;
    protected onContinueDialog(innerDC: DialogContext): Promise<DialogTurnResult>;
    protected onEndDialog(context: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    protected onRepromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(outerDC: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
}

// @public
export interface ComponentMemoryScopes {
    // (undocumented)
    getMemoryScopes(): MemoryScope[];
}

// @public
export interface ComponentPathResolvers {
    // (undocumented)
    getPathResolvers(): PathResolver[];
}

// @public
export abstract class Configurable {
    configure(config: Record<string, unknown>): this;
    // (undocumented)
    getConverter(_property: string): Converter | ConverterFactory;
}

// @public
export class ConfirmPrompt extends Prompt<boolean> {
    // Warning: (ae-forgotten-export) The symbol "ChoiceDefaultsConfirmPrompt" needs to be exported by the entry point index.d.ts
    constructor(dialogId: string, validator?: PromptValidator<boolean>, defaultLocale?: string, choiceDefaults?: ChoiceDefaultsConfirmPrompt);
    choiceOptions: ChoiceFactoryOptions | undefined;
    confirmChoices: (string | Choice)[] | undefined;
    defaultLocale: string | undefined;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: any, options: PromptOptions): Promise<PromptRecognizerResult<boolean>>;
    style: ListStyle;
}

// @public
export class ConversationMemoryScope extends BotStateMemoryScope {
    constructor();
    // (undocumented)
    protected stateKey: string;
}

// @public
export interface Converter<From = unknown, To = unknown> {
    // (undocumented)
    convert(value: From | To): To;
}

// @public (undocumented)
export type ConverterFactory<From = unknown, To = unknown> = {
    new (...args: unknown[]): Converter<From, To>;
};

// @public
export class DateTimePrompt extends Prompt<DateTimeResolution[]> {
    constructor(dialogId: string, validator?: PromptValidator<DateTimeResolution[]>, defaultLocale?: string);
    defaultLocale: string | undefined;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: any, options: PromptOptions): Promise<PromptRecognizerResult<DateTimeResolution[]>>;
}

// @public
export interface DateTimeResolution {
    timex: string;
    type: string;
    value: string;
}

// @public
export function defaultTokenizer(text: string, locale?: string): Token[];

// @public
export abstract class Dialog<O extends object = {}> extends Configurable {
    constructor(dialogId?: string);
    abstract beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    endDialog(context: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    static EndOfTurn: DialogTurnResult;
    getVersion(): string;
    get id(): string;
    // Warning: (ae-setter-with-docs) The doc comment for the property "id" must appear on the getter, not the setter.
    set id(value: string);
    protected onComputeId(): string;
    onDialogEvent(dc: DialogContext, e: DialogEvent): Promise<boolean>;
    protected onPostBubbleEvent(dc: DialogContext, e: DialogEvent): Promise<boolean>;
    protected onPreBubbleEvent(dc: DialogContext, e: DialogEvent): Promise<boolean>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    get telemetryClient(): BotTelemetryClient;
    // Warning: (ae-setter-with-docs) The doc comment for the property "telemetryClient" must appear on the getter, not the setter.
    set telemetryClient(client: BotTelemetryClient);
    protected _telemetryClient: BotTelemetryClient;
}

// @public
export class DialogClassMemoryScope extends ClassMemoryScope {
    constructor();
    // (undocumented)
    protected onFindDialog(dc: DialogContext): Dialog;
}

// @public (undocumented)
export interface DialogConfiguration {
    id?: string;
    telemetryClient?: BotTelemetryClient;
}

// @public
export abstract class DialogContainer<O extends object = {}> extends Dialog<O> {
    protected checkForVersionChange(dc: DialogContext): Promise<void>;
    abstract createChildContext(dc: DialogContext): DialogContext | undefined;
    readonly dialogs: DialogSet;
    findDialog(dialogId: string): Dialog | undefined;
    protected getInternalVersion(): string;
    onDialogEvent(dc: DialogContext, e: DialogEvent): Promise<boolean>;
    // Warning: (ae-setter-with-docs) The doc comment for the property "telemetryClient" must appear on the getter, not the setter.
    set telemetryClient(client: BotTelemetryClient);
    get telemetryClient(): BotTelemetryClient;
}

// @public
export class DialogContext {
    constructor(dialogs: DialogSet, contextOrDC: TurnContext, state: DialogState);
    constructor(dialogs: DialogSet, contextOrDC: DialogContext, state: DialogState);
    get activeDialog(): DialogInstance | undefined;
    beginDialog(dialogId: string, options?: object): Promise<DialogTurnResult>;
    cancelAllDialogs(cancelParents?: boolean, eventName?: string, eventValue?: any): Promise<DialogTurnResult>;
    get child(): DialogContext | undefined;
    context: TurnContext;
    continueDialog(): Promise<DialogTurnResult>;
    get dialogManager(): DialogManager;
    dialogs: DialogSet;
    emitEvent(name: string, value?: any, bubble?: boolean, fromLeaf?: boolean): Promise<boolean>;
    endDialog(result?: any): Promise<DialogTurnResult>;
    findDialog(dialogId: string): Dialog | undefined;
    getLocale(): string;
    parent: DialogContext | undefined;
    prompt(dialogId: string, promptOrOptions: string | Partial<Activity> | PromptOptions): Promise<DialogTurnResult>;
    prompt(dialogId: string, promptOrOptions: string | Partial<Activity> | PromptOptions, choices: (string | Choice)[]): Promise<DialogTurnResult>;
    replaceDialog(dialogId: string, options?: object): Promise<DialogTurnResult>;
    repromptDialog(): Promise<void>;
    services: TurnContextStateCollection;
    stack: DialogInstance[];
    state: DialogStateManager;
}

// @public
export class DialogContextError extends Error {
    constructor(error: Error | string, dialogContext: DialogContext);
    readonly dialogContext: {
        activeDialog?: string;
        parent?: string;
        stack: DialogInstance[];
    };
    // (undocumented)
    readonly error: Error | string;
}

// @public
export class DialogContextMemoryScope extends MemoryScope {
    constructor();
    getMemory(dc: DialogContext): Record<'stack' | 'activeDialog' | 'parent', unknown>;
}

// @public (undocumented)
export interface DialogDependencies {
    getDependencies(): Dialog[];
}

// @public (undocumented)
export interface DialogEvent {
    bubble: boolean;
    name: string;
    value?: any;
}

// @public
export class DialogEvents {
    static readonly activityReceived = "activityReceived";
    static readonly beginDialog = "beginDialog";
    static readonly cancelDialog = "cancelDialog";
    static readonly error = "error";
    static readonly repromptDialog = "repromptDialog";
    static readonly versionChanged = "versionChanged";
}

// @public
export interface DialogInstance<T = any> {
    id: string;
    state: T;
    version?: string;
}

// @public
export class DialogManager extends Configurable {
    constructor(rootDialog?: Dialog, dialogStateProperty?: string);
    configure(config: Partial<DialogManagerConfiguration>): this;
    conversationState: ConversationState;
    dialogs: DialogSet;
    expireAfter?: number;
    get initialTurnState(): TurnContextStateCollection;
    onTurn(context: TurnContext): Promise<DialogManagerResult>;
    // Warning: (ae-setter-with-docs) The doc comment for the property "rootDialog" must appear on the getter, not the setter.
    set rootDialog(value: Dialog);
    get rootDialog(): Dialog;
    stateConfiguration?: DialogStateManagerConfiguration;
    userState?: UserState;
}

// @public (undocumented)
export interface DialogManagerConfiguration {
    conversationState: BotState;
    expireAfter?: number;
    rootDialog: Dialog;
    stateConfiguration?: DialogStateManagerConfiguration;
    userState?: UserState;
}

// @public (undocumented)
export interface DialogManagerResult {
    // (undocumented)
    turnResult: DialogTurnResult;
}

// @public
export class DialogMemoryScope extends MemoryScope {
    constructor();
    getMemory(dc: DialogContext): object;
    setMemory(dc: DialogContext, memory: object): void;
}

// @public
export class DialogPath {
    // (undocumented)
    static readonly defaultOperation = "dialog.defaultOperation";
    // (undocumented)
    static readonly eventCounter = "dialog.eventCounter";
    // (undocumented)
    static readonly expectedProperties = "dialog.expectedProperties";
    // (undocumented)
    static readonly lastEvent = "dialog.lastEvent";
    // (undocumented)
    static readonly lastIntent = "dialog.lastIntent";
    // (undocumented)
    static readonly lastTriggerEvent = "dialog.lastTriggerEvent";
    // (undocumented)
    static readonly requiredProperties = "dialog.requiredProperties";
    // (undocumented)
    static readonly retries = "dialog.retries";
}

// @public
export enum DialogReason {
    beginCalled = "beginCalled",
    cancelCalled = "cancelCalled",
    continueCalled = "continueCalled",
    endCalled = "endCalled",
    nextCalled = "nextCalled",
    replaceCalled = "replaceCalled"
}

// @public (undocumented)
export class DialogsBotComponent extends BotComponent {
    // (undocumented)
    configureServices(services: ServiceCollection, configuration: Configuration): void;
}

// @public
export class DialogSet {
    constructor(dialogState?: StatePropertyAccessor<DialogState>);
    add<T extends Dialog>(dialog: T): this;
    createContext(context: TurnContext): Promise<DialogContext>;
    find(dialogId: string): Dialog | undefined;
    getDialogs(): Dialog[];
    getVersion(): string;
    get telemetryClient(): BotTelemetryClient;
    // Warning: (ae-setter-with-docs) The doc comment for the property "telemetryClient" must appear on the getter, not the setter.
    set telemetryClient(client: BotTelemetryClient);
    }

// @public
export interface DialogState {
    dialogStack: DialogInstance[];
}

// @public
export class DialogStateManager {
    constructor(dc: DialogContext, configuration?: DialogStateManagerConfiguration);
    anyPathChanged(counter: number, paths: string[]): boolean;
    configuration: DialogStateManagerConfiguration;
    deleteScopesMemory(name: string): Promise<void>;
    deleteValue(pathExpression: string): void;
    getMemorySnapshot(): object;
    getValue<T = any>(pathExpression: string, defaultValue?: T | (() => T)): T;
    loadAllScopes(): Promise<void>;
    parsePath(pathExpression: string, allowNestedPaths?: boolean): (string | number)[];
    saveAllChanges(): Promise<void>;
    setValue(pathExpression: string, value: any): void;
    trackPaths(paths: string[]): string[];
    transformPath(pathExpression: string): string;
    version(): string;
}

// @public (undocumented)
export interface DialogStateManagerConfiguration {
    readonly memoryScopes: MemoryScope[];
    readonly pathResolvers: PathResolver[];
}

// @public
export interface DialogTurnResult<T = any> {
    parentEnded?: boolean;
    result?: T;
    status: DialogTurnStatus;
}

// @public
export class DialogTurnStateConstants {
    // (undocumented)
    static configuration: symbol;
    // (undocumented)
    static dialogManager: symbol;
    // (undocumented)
    static queueStorage: symbol;
    // (undocumented)
    static telemetryClient: symbol;
}

// @public
export enum DialogTurnStatus {
    cancelled = "cancelled",
    complete = "complete",
    completeAndWait = "completeAndWait",
    empty = "empty",
    waiting = "waiting"
}

// @public
export class DollarPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export function findChoices(utterance: string, choices: (string | Choice)[], options?: FindChoicesOptions): ModelResult<FoundChoice>[];

// @public
export interface FindChoicesOptions extends FindValuesOptions {
    noAction?: boolean;
    noValue?: boolean;
    recognizeNumbers?: boolean;
    recognizeOrdinals?: boolean;
}

// @public
export function findValues(utterance: string, values: SortedValue[], options?: FindValuesOptions): ModelResult<FoundValue>[];

// @public
export interface FindValuesOptions {
    allowPartialMatches?: boolean;
    locale?: string;
    maxTokenDistance?: number;
    tokenizer?: TokenizerFunction;
}

// @public
export interface FoundChoice {
    // (undocumented)
    index: number;
    score: number;
    // (undocumented)
    synonym?: string;
    // (undocumented)
    value: string;
}

// @public
export interface FoundValue {
    index: number;
    score: number;
    value: string;
}

// @public (undocumented)
export function getChannelId(context: TurnContext): string;

// @public
export class HashPathResolver extends AliasPathResolver {
    constructor();
}

// @public (undocumented)
export function hasMessageFeed(_channelId: string): boolean;

// @public
export function isComponentMemoryScopes(component: unknown): component is ComponentMemoryScopes;

// @public
export function isComponentPathResolvers(component: unknown): component is ComponentPathResolvers;

// @public
export enum ListStyle {
    auto = 1,
    heroCard = 5,
    inline = 2,
    list = 3,
    none = 0,
    suggestedAction = 4
}

// @public (undocumented)
export function maxActionTitleLength(channelId: string): number;

// @public
export abstract class MemoryScope {
    constructor(name: string, includeInSnapshot?: boolean);
    delete(dc: DialogContext): Promise<void>;
    abstract getMemory(dc: DialogContext): object;
    readonly includeInSnapshot: boolean;
    load(dc: DialogContext): Promise<void>;
    readonly name: string;
    saveChanges(dc: DialogContext): Promise<void>;
    setMemory(dc: DialogContext, memory: object): void;
}

// @public
export interface ModelResult<T extends Record<string, any> = {}> {
    end: number;
    resolution: T;
    start: number;
    text: string;
    typeName: string;
}

// @public
export class NumberPrompt extends Prompt<number> {
    constructor(dialogId: string, validator?: PromptValidator<number>, defaultLocale?: string);
    defaultLocale?: string;
    protected onPrompt(context: TurnContext, state: unknown, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: unknown, options: PromptOptions): Promise<PromptRecognizerResult<number>>;
}

// @public
export class OAuthPrompt extends Dialog {
    constructor(dialogId: string, settings: OAuthPromptSettings, validator?: PromptValidator<TokenResponse>);
    beginDialog(dc: DialogContext, options?: PromptOptions): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    getUserToken(context: TurnContext, code?: string): Promise<TokenResponse | undefined>;
    recognizeToken(dc: DialogContext): Promise<PromptRecognizerResult<TokenResponse>>;
    static sendOAuthCard(settings: OAuthPromptSettings, turnContext: TurnContext, prompt?: string | Partial<Activity>): Promise<void>;
    signOutUser(context: TurnContext): Promise<void>;
    }

// @public
export interface OAuthPromptSettings {
    connectionName: string;
    endOnInvalidMessage?: boolean;
    oAuthAppCredentials?: CoreAppCredentials;
    text?: string;
    timeout?: number;
    title: string;
}

// @public
export interface PathResolver {
    transformPath(path: string): string;
}

// @public
export class PercentPathResolver extends AliasPathResolver {
    constructor();
}

// @public
export abstract class Prompt<T> extends Dialog {
    protected constructor(dialogId: string, validator?: PromptValidator<T>);
    protected appendChoices(prompt: string | Partial<Activity>, channelId: string, choices: (string | Choice)[], style: ListStyle, options?: ChoiceFactoryOptions): Partial<Activity>;
    beginDialog(dc: DialogContext, options: PromptOptions): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    protected onPreBubbleEvent(dc: DialogContext, event: DialogEvent): Promise<boolean>;
    protected abstract onPrompt(context: TurnContext, state: object, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected abstract onRecognize(context: TurnContext, state: object, options: PromptOptions): Promise<PromptRecognizerResult<T>>;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    }

// @public (undocumented)
export interface PromptCultureModel {
    inlineOr: string;
    inlineOrMore: string;
    locale: string;
    noInLanguage: string;
    separator: string;
    yesInLanguage: string;
}

// @public
export class PromptCultureModels {
    // (undocumented)
    static Chinese: PromptCultureModel;
    // (undocumented)
    static Dutch: PromptCultureModel;
    // (undocumented)
    static English: PromptCultureModel;
    // (undocumented)
    static French: PromptCultureModel;
    // (undocumented)
    static German: PromptCultureModel;
    // (undocumented)
    static getSupportedCultures: () => PromptCultureModel[];
    // (undocumented)
    static Italian: PromptCultureModel;
    // (undocumented)
    static Japanese: PromptCultureModel;
    static mapToNearestLanguage(cultureCode: string): string;
    // (undocumented)
    static Portuguese: PromptCultureModel;
    // (undocumented)
    static Spanish: PromptCultureModel;
}

// @public
export interface PromptOptions {
    choices?: (string | Choice)[];
    prompt?: string | Partial<Activity>;
    retryPrompt?: string | Partial<Activity>;
    style?: ListStyle;
    validations?: object;
}

// @public
export interface PromptRecognizerResult<T> {
    succeeded: boolean;
    value?: T;
}

// @public
export type PromptValidator<T> = (prompt: PromptValidatorContext<T>) => Promise<boolean>;

// @public
export interface PromptValidatorContext<T> {
    readonly attemptCount: number;
    readonly context: TurnContext;
    readonly options: PromptOptions;
    readonly recognized: PromptRecognizerResult<T>;
    readonly state: object;
}

// @public
export function recognizeChoices(utterance: string, choices: (string | Choice)[], options?: FindChoicesOptions): ModelResult<FoundChoice>[];

// @public
export class Recognizer extends Configurable implements RecognizerConfiguration {
    protected createChooseIntentResult(recognizerResults: Record<string, RecognizerResult>): RecognizerResult;
    protected fillRecognizerResultTelemetryProperties(recognizerResult: RecognizerResult, telemetryProperties: Record<string, string>, dialogContext?: DialogContext): Record<string, string>;
    id: string;
    recognize(dialogContext: DialogContext, activity: Partial<Activity>, telemetryProperties?: Record<string, string>, telemetryMetrics?: Record<string, number>): Promise<RecognizerResult>;
    // (undocumented)
    protected stringifyAdditionalPropertiesOfRecognizerResult(recognizerResult: RecognizerResult): string;
    telemetryClient: BotTelemetryClient;
    protected trackRecognizerResult(dialogContext: DialogContext, eventName: string, telemetryProperties?: Record<string, string>, telemetryMetrics?: Record<string, number>): void;
}

// @public (undocumented)
export interface RecognizerConfiguration {
    // (undocumented)
    id?: string;
    // (undocumented)
    telemetryClient?: BotTelemetryClient;
}

// @public
export function runDialog(dialog: Dialog, context: TurnContext, accessor: StatePropertyAccessor<DialogState>): Promise<void>;

// @public
export class ScopePath {
    static readonly class = "class";
    static readonly conversation = "conversation";
    static readonly dialog = "dialog";
    static readonly dialogClass = "dialogClass";
    static readonly dialogContext = "dialogContext";
    static readonly settings = "settings";
    static readonly this = "this";
    static readonly turn = "turn";
    static readonly user = "user";
}

// @public
export class SettingsMemoryScope extends MemoryScope {
    constructor(initialSettings?: Record<string, unknown>);
    getMemory(dc: DialogContext): Record<string, unknown>;
    // (undocumented)
    load(dc: DialogContext): Promise<void>;
    protected static loadSettings(configuration: Record<string, string>): Record<string, unknown>;
}

// @public
export class SkillDialog extends Dialog<Partial<BeginSkillDialogOptions>> {
    constructor(dialogOptions: SkillDialogOptions, dialogId?: string);
    beginDialog(dc: DialogContext, options: BeginSkillDialogOptions): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    // (undocumented)
    protected dialogOptions: SkillDialogOptions;
    endDialog(context: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    protected onValidateActivity(activity: Activity): boolean;
    repromptDialog(context: TurnContext, instance: DialogInstance): Promise<void>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    }

// @public (undocumented)
export interface SkillDialogOptions {
    botId: string;
    connectionName?: string;
    conversationIdFactory: SkillConversationIdFactoryBase;
    conversationState: ConversationState;
    skill: BotFrameworkSkill;
    skillClient: BotFrameworkClient;
    skillHostEndpoint: string;
}

// @public
export interface SortedValue {
    // (undocumented)
    index: number;
    // (undocumented)
    value: string;
}

// @public (undocumented)
export function supportsCardActions(channelId: string, buttonCnt?: number): boolean;

// @public (undocumented)
export function supportsSuggestedActions(channelId: string, buttonCnt?: number): boolean;

// @public
export interface TemplateInterface<T, D = Record<string, unknown>> {
    bind(dialogContext: DialogContext, data?: D): Promise<T>;
}

// @public
export class TextPrompt extends Prompt<string> {
    constructor(dialogId?: string, validator?: PromptValidator<string>);
    protected onPreBubbleEvent(dc: DialogContext, event: DialogEvent): Promise<boolean>;
    protected onPrompt(context: TurnContext, state: any, options: PromptOptions, isRetry: boolean): Promise<void>;
    protected onRecognize(context: TurnContext, state: any, options: PromptOptions): Promise<PromptRecognizerResult<string>>;
}

// @public
export class ThisMemoryScope extends MemoryScope {
    constructor();
    getMemory(dc: DialogContext): object;
    setMemory(dc: DialogContext, memory: object): void;
}

// @public
export class ThisPath {
    static readonly options = "this.options";
}

// @public
export interface Token {
    end: number;
    normalized: string;
    start: number;
    text: string;
}

// @public
export type TokenizerFunction = (text: string, locale?: string) => Token[];

// @public
export class TurnMemoryScope extends MemoryScope {
    constructor();
    getMemory(dc: DialogContext): object;
    setMemory(dc: DialogContext, memory: object): void;
}

// @public
export class TurnPath {
    // (undocumented)
    static readonly activity = "turn.activity";
    // (undocumented)
    static readonly activityProcessed = "turn.activityProcessed";
    // (undocumented)
    static readonly dialogEvent = "turn.dialogEvent";
    // (undocumented)
    static readonly interrupted = "turn.interrupted";
    // (undocumented)
    static readonly lastResult = "turn.lastresult";
    // (undocumented)
    static readonly recognized = "turn.recognized";
    // (undocumented)
    static readonly recognizedEntities = "turn.recognizedEntities";
    // (undocumented)
    static readonly repeatedIds = "turn.repeatedIds";
    // (undocumented)
    static readonly text = "turn.recognized.text";
    // (undocumented)
    static readonly topIntent = "turn.recognized.intent";
    // (undocumented)
    static readonly topScore = "turn.recognized.score";
    // (undocumented)
    static readonly unrecognizedText = "turn.unrecognizedText";
}

// @public
export class UserMemoryScope extends BotStateMemoryScope {
    constructor();
    // (undocumented)
    protected stateKey: string;
}

// @public
export class WaterfallDialog<O extends object = {}> extends Dialog<O> {
    constructor(dialogId: string, steps?: WaterfallStep<O>[]);
    addStep(step: WaterfallStep<O>): this;
    beginDialog(dc: DialogContext, options?: O): Promise<DialogTurnResult>;
    continueDialog(dc: DialogContext): Promise<DialogTurnResult>;
    endDialog(context: TurnContext, instance: DialogInstance, reason: DialogReason): Promise<void>;
    getVersion(): string;
    protected onStep(step: WaterfallStepContext<O>): Promise<DialogTurnResult>;
    resumeDialog(dc: DialogContext, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    protected runStep(dc: DialogContext, index: number, reason: DialogReason, result?: any): Promise<DialogTurnResult>;
    }

// @public
export type WaterfallStep<O extends object = {}> = (step: WaterfallStepContext<O>) => Promise<DialogTurnResult>;

// @public
export class WaterfallStepContext<O extends object = {}> extends DialogContext {
    constructor(dc: DialogContext, info: WaterfallStepInfo<O>);
    get index(): number;
    next(result?: any): Promise<DialogTurnResult>;
    get options(): O;
    get reason(): DialogReason;
    get result(): any;
    get values(): object;
}

// @public
export interface WaterfallStepInfo<O extends object> {
    index: number;
    onNext(result?: any): Promise<DialogTurnResult>;
    options: O;
    reason: DialogReason;
    result: any;
    values: object;
}


// (No @packageDocumentation comment for this package)

```
