/**
 * Microsoft Bot Connector API - v3.0
 * The Bot Connector REST API allows your bot to send and receive messages to channels configured in the  [Bot Framework Developer Portal](https://dev.botframework.com). The Connector service uses industry-standard REST  and JSON over HTTPS.    Client libraries for this REST API are available. See below for a list.    Many bots will use both the Bot Connector REST API and the associated [Bot State REST API](/en-us/restapi/state). The  Bot State REST API allows a bot to store and retrieve state associated with users and conversations.    Authentication for both the Bot Connector and Bot State REST APIs is accomplished with JWT Bearer tokens, and is  described in detail in the [Connector Authentication](/en-us/restapi/authentication) document.    # Client Libraries for the Bot Connector REST API    * [Bot Builder for C#](/en-us/csharp/builder/sdkreference/)  * [Bot Builder for Node.js](/en-us/node/builder/overview/)  * Generate your own from the [Connector API Swagger file](https://raw.githubusercontent.com/Microsoft/BotBuilder/master/CSharp/Library/Microsoft.Bot.Connector.Shared/Swagger/ConnectorAPI.json)    Â© 2016 Microsoft
 *
 * The version of the OpenAPI document: v3
 * Contact: botframework@microsoft.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { AttachmentData } from './model/attachmentData';
import { ConversationResourceResponse } from './model/conversationResourceResponse';

import { Transcript } from './model/transcript';
import { MicrosoftAppCredentials } from '../auth'
import { ObjectSerializer, Authentication, OAuth, VoidAuth } from './model/models';
import { CreateConversationResponse, ConversationParameters, PagedParameters, DeleteActivityResponse, useResourceResponse } from './model';
import { SimpleCredential } from './simpleCredential';
import { GetConversationMembersResponse } from './model/responses/getConversationMembersResponse';

let defaultBasePath = 'https://api.botframework.com';

export enum ConversationsApiApiKeys {
}

export class ConversationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;
    protected credentials: SimpleCredential;

    protected authentications = {
        'default': <Authentication> new VoidAuth(),
    }

    constructor(CustomCredentials: SimpleCredential)
    constructor(CustomCredentials: SimpleCredential, basePath?: string){
        if(basePath)
         this.basePath = basePath;
         
        if(CustomCredentials){
            this.credentials = new SimpleCredential(CustomCredentials.appId, CustomCredentials.appPassword);
        }        
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: ConversationsApiApiKeys, value: string) {
        (this.authentications as any)[ConversationsApiApiKeys[key]].apiKey = value;
    }

    private async AuthenticateRequest(){
        const tokenGenerator = new MicrosoftAppCredentials(this.credentials.appId, this.credentials.appPassword);
        return `${ await tokenGenerator.getToken(true) }`;
    }


    public async createConversation (parameters: ConversationParameters)
                                    : Promise<CreateConversationResponse> {
                                                    
        const localVarPath = this.basePath + '/v3/conversations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'parameters' is not null or undefined
        if (parameters == null) {
            throw new Error('Required parameter parameters was null or undefined when calling conversationsCreateConversation.');
        }

        Object.assign(localVarHeaderParams, parameters.headers);

        this.setDefaultAuthentication(new OAuth(await this.AuthenticateRequest()));  

        let localVarRequestOptions: request.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "ConversationParameters")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);
        let localVarUseFormData = false;

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }

        return new Promise<CreateConversationResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {                    
                    let _body: CreateConversationResponse = ObjectSerializer.deserialize(response, "ConversationResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: CreateConversationResponse = Object.assign(_body, {_response: _response});
                        resolve(toReturn);
                    } else {
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: CreateConversationResponse = Object.assign(_body, {_response: _response});  
                        reject(toReturn);
                    }
                }
            });
        });
    }

    /**
     * Delete an existing activity.    
     * Some channels allow you to delete an existing activity, and if successful this method will remove the specified activity.
     * @summary DeleteActivity
     * @param conversationId Conversation ID
     * @param activityId activityId to delete
     */
    public async deleteActivity (parameters: ConversationParameters) 
        : Promise<DeleteActivityResponse> {
        
            const localVarPath = this.basePath + '/v3/conversations/{conversationId}/activities/{activityId}'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)))
            .replace('{' + 'activityId' + '}', encodeURIComponent(String(parameters.activity.id)));
        
        let localVarQueryParameters: {};
        let localVarHeaderParams = Object.assign({}, this.defaultHeaders);
        let localVarFormParams = {};

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.activity.conversation.id == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsDeleteActivity.');
        }

        // verify required parameter 'activityId' is not null or undefined
        if (parameters.activity.conversation.id == null) {
            throw new Error('Required parameter activityId was null or undefined when calling conversationsDeleteActivity.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<DeleteActivityResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: DeleteActivityResponse = ObjectSerializer.deserialize(response, "{ [key: string]: TokenResponse; }");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: DeleteActivityResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * Deletes a member from a conversation.     
     * This REST API takes a ConversationId and a memberId (of type string) and removes that member from the conversation. 
     * If that member was the last member  of the conversation, the conversation will also be deleted.
     * @summary DeleteConversationMember
     * @param conversationId Conversation ID
     * @param memberId ID of the member to delete from this conversation
     */
    public async deleteConversationMember (
        memberId: string,
        parameters: ConversationParameters) 
        : Promise<DeleteActivityResponse> {
        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/members/{memberId}'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)))
            .replace('{' + 'memberId' + '}', encodeURIComponent(String(memberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsDeleteConversationMember.');
        }

        // verify required parameter 'memberId' is not null or undefined
        if (memberId == null) {
            throw new Error('Required parameter memberId was null or undefined when calling conversationsDeleteConversationMember.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<DeleteActivityResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: DeleteActivityResponse = ObjectSerializer.deserialize(response, "{ [key: string]: TokenResponse; }");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: DeleteActivityResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * Enumerate the members of an activity.     
     * This REST API takes a ConversationId and a ActivityId, returning an array 
     * of ChannelAccount objects representing the members of the particular activity in the conversation.
     * @summary GetActivityMembers
     * @param conversationId Conversation ID
     * @param activityId Activity ID
     */
    public async getActivityMembers (parameters: ConversationParameters): Promise<DeleteActivityResponse> {

        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/activities/{activityId}/members'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)))
            .replace('{' + 'activityId' + '}', encodeURIComponent(String(parameters.activity.id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsGetActivityMembers.');
        }

        // verify required parameter 'activityId' is not null or undefined
        if (parameters.activity.id == null) {
            throw new Error('Required parameter activityId was null or undefined when calling conversationsGetActivityMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<DeleteActivityResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: DeleteActivityResponse = ObjectSerializer.deserialize(response, "{ [key: string]: TokenResponse; }");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: DeleteActivityResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * Enumerate the members of a conversation.     
     * This REST API takes a ConversationId and returns an array of ChannelAccount objects representing the members of the conversation.
     * @summary GetConversationMembers
     * @param conversationId Conversation ID
     */
    public async getConversationMembers (parameters: ConversationParameters) 
        : Promise<GetConversationMembersResponse> {
        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/members'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsGetConversationMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<GetConversationMembersResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: GetConversationMembersResponse = ObjectSerializer.deserialize(response, "ChannelAccount[]");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: GetConversationMembersResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * Enumerate the members of a conversation one page at a time.    
     * This REST API takes a ConversationId. Optionally a pageSize and/or continuationToken 
     * can be provided. It returns a PagedMembersResult, which contains an array  
     * of ChannelAccounts representing the members of the conversation and a continuation 
     * token that can be used to get more values.    
     * One page of ChannelAccounts records are returned with each call. 
     * The number of records in a page may vary between channels and calls. 
     * The pageSize parameter can be used as a suggestion. 
     * If there are no additional results the response will not contain a continuation token. 
     * If there are no members in the conversation the Members will be empty or not present in the response.    
     * A response to a request that has a continuation token from a prior request may rarely return members 
     * from a previous request.
     * @summary GetConversationPagedMembers
     * @param conversationId Conversation ID
     * @param pageSize Suggested page size
     * @param continuationToken Continuation Token
     */
    public async getConversationPagedMembers (parameters: PagedParameters) 
        : Promise<useResourceResponse> {

        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/pagedmembers'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsGetConversationPagedMembers.');
        }

        if (parameters.pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(parameters.pageSize, "number");
        }

        if (parameters.continuationToken !== undefined) {
            localVarQueryParameters['continuationToken'] = ObjectSerializer.serialize(parameters.continuationToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * List the Conversations in which this bot has participated.    
     * 
     * GET from this method with a skip token    
     * 
     * The return value is a ConversationsResult, which contains an array of ConversationMembers and a skip token.  
     * If the skip token is not empty, then there are further values to be returned. 
     * Call this method again with the returned token to get more values.    
     * 
     * Each ConversationMembers object contains the ID of the conversation and an array of 
     * ChannelAccounts that describe the members of the conversation.
     * @summary GetConversations
     * @param continuationToken skip or continuation token
     */
    public async getConversations (parameters: ConversationParameters = {headers: {}}) 
                                    : Promise<useResourceResponse> {
        const localVarPath = this.basePath + '/v3/conversations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * This method allows you to reply to an activity.    
     * This is slightly different from SendToConversation().  
     * * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  
     * * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. 
     * If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    
     * Use ReplyToActivity when replying to a specific activity in the conversation.    
     * Use SendToConversation in all other cases.
     * @summary ReplyToActivity
     * @param activity Activity to send
     * @param conversationId Conversation ID
     * @param activityId activityId the reply is to (OPTIONAL)
     */
    public async replyToActivity (parameters: ConversationParameters)
                                : Promise<useResourceResponse> {

        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/activities/{activityId}'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.activity.conversation.id)))
            .replace('{' + 'activityId' + '}', encodeURIComponent(String(parameters.activity.id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'activity' is not null or undefined
        if (parameters.activity == null) {
            throw new Error('Required parameter activity was null or undefined when calling conversationsReplyToActivity.');
        }

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.activity.conversation.id == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsReplyToActivity.');
        }

        // verify required parameter 'activityId' is not null or undefined
        if (parameters.activity.id == null) {
            throw new Error('Required parameter activityId was null or undefined when calling conversationsReplyToActivity.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters.activity, "Activity")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * This method allows you to upload the historic activities to the conversation.    
     * Sender must ensure that the historic activities have unique ids and appropriate timestamps. 
     * The ids are used by the client to deal with duplicate activities and the timestamps are used 
     * by the client to render the activities in the right order.
     * @summary SendConversationHistory
     * @param history Historic activities
     * @param conversationId Conversation ID
     */
    public async sendConversationHistory (parameters: ConversationParameters,
                                        history: Transcript) 
                                        : Promise<useResourceResponse> {

        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/activities/history'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'history' is not null or undefined
        if (history == null) {
            throw new Error('Required parameter history was null or undefined when calling SendConversationHistory.');
        }
        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling SendConversationHistory.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;
        let localVarRequestOptions: request.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(history, "Transcript")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * This method allows you to send an activity to the end of a conversation.    
     * This is slightly different from ReplyToActivity().  
     * * SendToConversation(conversationId) - will append the activity to the end of the conversation according to the timestamp or semantics of the channel.  
     * * ReplyToActivity(conversationId,ActivityId) - adds the activity as a reply to another activity, if the channel supports it. 
     * If the channel does not support nested replies, ReplyToActivity falls back to SendToConversation.    
     * Use ReplyToActivity when replying to a specific activity in the conversation.    
     * Use SendToConversation in all other cases.
     * @summary SendToConversation
     * @param activity Activity to send
     * @param conversationId Conversation ID
     */
    public async sendToConversation (parameters: ConversationParameters) 
                                    : Promise<useResourceResponse> {
                                        
        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/activities'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'activity' is not null or undefined
        if (parameters.activity == null) {
            throw new Error('Required parameter activity was null or undefined when calling SendToConversation.');
        }

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling SendToConversation.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters.activity, "Activity")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * Edit an existing activity.    
     * Some channels allow you to edit an existing activity to reflect the new state of a bot conversation.    
     * For example, you can remove buttons after someone has clicked \"Approve\" button.
     * @summary UpdateActivity
     * @param activity replacement Activity
     * @param conversationId Conversation ID
     * @param activityId activityId to update
     */
    public async updateActivity (parameters: ConversationParameters) 
                                : Promise<useResourceResponse> {

        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/activities/{activityId}'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)))
            .replace('{' + 'activityId' + '}', encodeURIComponent(String(parameters.activity.id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'activity' is not null or undefined
        if (parameters.activity == null) {
            throw new Error('Required parameter activity was null or undefined when calling conversationsUpdateActivity.');
        }

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsUpdateActivity.');
        }

        // verify required parameter 'activityId' is not null or undefined
        if (parameters.activity.id == null) {
            throw new Error('Required parameter activityId was null or undefined when calling conversationsUpdateActivity.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters.activity, "Activity")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }

    /**
     * Upload an attachment directly into a channel\'s blob storage.    
     * This is useful because it allows you to store data in a compliant store when dealing with enterprises.    
     * The response is a ResourceResponse which contains an AttachmentId which is suitable for using with 
     * the attachments API.
     * @summary UploadAttachment
     * @param attachmentUpload Attachment data
     * @param conversationId Conversation ID
     */
    public async uploadAttachment (parameters: ConversationParameters,
                                    attachmentUpload: AttachmentData) 
                                    : Promise<useResourceResponse> {

        const localVarPath = this.basePath + '/v3/conversations/{conversationId}/attachments'
            .replace('{' + 'conversationId' + '}', encodeURIComponent(String(parameters.conversationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'attachmentUpload' is not null or undefined
        if (attachmentUpload == null) {
            throw new Error('Required parameter attachmentUpload was null or undefined when calling conversationsUploadAttachment.');
        }

        // verify required parameter 'conversationId' is not null or undefined
        if (parameters.conversationId == null) {
            throw new Error('Required parameter conversationId was null or undefined when calling conversationsUploadAttachment.');
        }

        (<any>Object).assign(localVarHeaderParams, parameters.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: request.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(attachmentUpload, "AttachmentData")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<useResourceResponse>((resolve, reject) => {
            request(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    let _body: useResourceResponse = ObjectSerializer.deserialize(response, "ResourceResponse");
                    let _bodyAsText = ObjectSerializer.deserialize(response, "string");
                    let httpResponse: http.IncomingMessage = response;

                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        let httpResponse: http.IncomingMessage = response;
                        let _response = Object.assign(httpResponse, {bodyAsText: _bodyAsText, parsedBody: _body});
                        let toReturn: useResourceResponse = Object.assign(_body, {_response: _response});                          
                        resolve(toReturn);
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
