## API Report File for "botbuilder-lg"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractParseTreeVisitor } from 'antlr4ts/tree';
import { ANTLRErrorListener } from 'antlr4ts';
import { ATN } from 'antlr4ts/atn/ATN';
import { CharStream } from 'antlr4ts/CharStream';
import { ExpressionParser } from 'adaptive-expressions';
import { Lexer } from 'antlr4ts/Lexer';
import { MemoryInterface } from 'adaptive-expressions';
import { Parser } from 'antlr4ts/Parser';
import { ParserRuleContext } from 'antlr4ts';
import { ParserRuleContext as ParserRuleContext_2 } from 'antlr4ts/ParserRuleContext';
import { ParseTree } from 'antlr4ts/tree';
import { ParseTreeListener } from 'antlr4ts/tree/ParseTreeListener';
import { ParseTreeVisitor } from 'antlr4ts/tree/ParseTreeVisitor';
import { RecognitionException } from 'antlr4ts';
import { Recognizer } from 'antlr4ts';
import { RuleContext } from 'antlr4ts/RuleContext';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { TokenStream } from 'antlr4ts/TokenStream';
import { Vocabulary } from 'antlr4ts/Vocabulary';

// @public
export class Analyzer extends AbstractParseTreeVisitor<AnalyzerResult> implements LGTemplateParserVisitor<AnalyzerResult> {
    constructor(templates: Templates, opt?: EvaluationOptions, analyzerOptions?: AnalyzerOptions);
    analyzeTemplate(templateName: string): AnalyzerResult;
    protected defaultResult(): AnalyzerResult;
    readonly templates: Templates;
    visitIfElseBody(ctx: IfElseBodyContext): AnalyzerResult;
    visitNormalBody(ctx: NormalBodyContext): AnalyzerResult;
    visitNormalTemplateBody(ctx: NormalTemplateBodyContext): AnalyzerResult;
    visitNormalTemplateString(ctx: NormalTemplateStringContext): AnalyzerResult;
    visitStructuredTemplateBody(ctx: StructuredTemplateBodyContext): AnalyzerResult;
    visitStructureValue(ctx: KeyValueStructureLineContext): AnalyzerResult;
    visitSwitchCaseBody(ctx: SwitchCaseBodyContext): AnalyzerResult;
}

// @public
export class AnalyzerOptions {
    constructor(options?: AnalyzerOptions | string[]);
    Merge(opt: AnalyzerOptions): AnalyzerOptions;
    ThrowOnRecursive?: boolean;
    }

// @public
export class AnalyzerResult {
    constructor(variables?: string[], templateRefNames?: string[]);
    TemplateReferences: string[];
    union(outputItem: AnalyzerResult): this;
    Variables: string[];
}

// @public (undocumented)
export class BodyContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    copyFrom(ctx: BodyContext): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class CommentDefinitionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    COMMENT(): TerminalNode;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class CustomizedMemory implements MemoryInterface {
    constructor(scope?: unknown, localMemory?: MemoryInterface);
    getValue(path: string): any;
    globalMemory: MemoryInterface;
    localMemory: MemoryInterface;
    setValue(_path: string, _value: any): void;
    version(): string;
}

// @public
export class Diagnostic {
    constructor(range: Range_2, message: string, severity?: DiagnosticSeverity, source?: string, code?: string);
    // (undocumented)
    code: string;
    // (undocumented)
    message: string;
    // (undocumented)
    range: Range_2;
    // (undocumented)
    severity: DiagnosticSeverity;
    // (undocumented)
    source: string;
    toString(): string;
}

// @public
export enum DiagnosticSeverity {
    // (undocumented)
    Error = 0,
    // (undocumented)
    Hint = 3,
    // (undocumented)
    Information = 2,
    // (undocumented)
    Warning = 1
}

// @public (undocumented)
export class ErrorDefinitionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    INVALID_LINE(): TerminalNode;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class ErrorListener implements ANTLRErrorListener<void> {
    constructor(errorSource: string, lineOffset?: number);
    syntaxError<T>(recognizer: Recognizer<T, any>, offendingSymbol: any, line: number, charPositionInLine: number, msg: string, e: RecognitionException | undefined): void;
}

// @public (undocumented)
export class ErrorStructuredNameContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRUCTURE_NAME(): TerminalNode[];
    // (undocumented)
    STRUCTURE_NAME(i: number): TerminalNode;
    // (undocumented)
    TEXT_IN_STRUCTURE_NAME(): TerminalNode[];
    // (undocumented)
    TEXT_IN_STRUCTURE_NAME(i: number): TerminalNode;
}

// @public (undocumented)
export class ErrorStructureLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(): TerminalNode[];
    // (undocumented)
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(i: number): TerminalNode;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    expressionInStructure(): ExpressionInStructureContext[];
    // (undocumented)
    expressionInStructure(i: number): ExpressionInStructureContext;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRUCTURE_EQUALS(): TerminalNode[];
    // (undocumented)
    STRUCTURE_EQUALS(i: number): TerminalNode;
    // (undocumented)
    STRUCTURE_IDENTIFIER(): TerminalNode[];
    // (undocumented)
    STRUCTURE_IDENTIFIER(i: number): TerminalNode;
    // (undocumented)
    STRUCTURE_OR_MARK(): TerminalNode[];
    // (undocumented)
    STRUCTURE_OR_MARK(i: number): TerminalNode;
    // (undocumented)
    TEXT_IN_STRUCTURE_BODY(): TerminalNode[];
    // (undocumented)
    TEXT_IN_STRUCTURE_BODY(i: number): TerminalNode;
}

// @public (undocumented)
export class ErrorTemplateStringContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    INVALID_TOKEN(): TerminalNode[];
    // (undocumented)
    INVALID_TOKEN(i: number): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class EvaluationOptions {
    constructor(opt?: EvaluationOptions | string[]);
    cacheScope: LGCacheScope | undefined;
    // (undocumented)
    LineBreakStyle: LGLineBreakStyle | undefined;
    locale: string;
    merge(opt: EvaluationOptions): EvaluationOptions;
    // (undocumented)
    nullSubstitution: (path: string) => unknown;
    // (undocumented)
    strictMode: boolean | undefined;
    }

// @public
export class EvaluationTarget {
    constructor(templateName: string, scope: MemoryInterface);
    cachedEvaluatedChildren: Map<string, unknown>;
    getId(): string;
    scope: MemoryInterface;
    templateName: string;
}

// @public
export class Evaluator extends AbstractParseTreeVisitor<unknown> implements LGTemplateParserVisitor<unknown> {
    constructor(templates: Templates, opt?: EvaluationOptions);
    // (undocumented)
    static readonly activityAttachmentFunctionName = "ActivityAttachment";
    static checkExpressionResult(exp: string, error: string, result: unknown, templateName: string, inlineContent?: string, errorPrefix?: string): void;
    static concatErrorMsg(firstError: string, secondError: string): string;
    constructScope(inputTemplateName: string, args: unknown[], allTemplates: Template[]): MemoryInterface;
    protected defaultResult(): string;
    evaluateTemplate(inputTemplateName: string, scope: unknown): unknown;
    // (undocumented)
    static readonly expandTextFunctionName = "expandText";
    readonly expressionParser: ExpressionParser;
    // (undocumented)
    static readonly fromFileFunctionName = "fromFile";
    // (undocumented)
    static readonly isTemplateFunctionName = "isTemplate";
    // (undocumented)
    static readonly LGType = "lgType";
    // (undocumented)
    static readonly ReExecuteSuffix = "!";
    // (undocumented)
    static readonly templateFunctionName = "template";
    readonly templateMap: {
        [name: string]: Template;
    };
    readonly templates: Templates;
    visitIfElseBody(ctx: IfElseBodyContext): unknown;
    visitNormalBody(ctx: NormalBodyContext): unknown;
    visitNormalTemplateBody(ctx: NormalTemplateBodyContext): unknown;
    visitNormalTemplateString(ctx: NormalTemplateStringContext): unknown;
    visitStructuredTemplateBody(ctx: StructuredTemplateBodyContext): unknown;
    visitSwitchCaseBody(ctx: SwitchCaseBodyContext): unknown;
    wrappedEvalTextContainsExpression(exp: string, regex: RegExp): string;
}

// @public
export class Expander extends AbstractParseTreeVisitor<unknown[]> implements LGTemplateParserVisitor<unknown[]> {
    constructor(templates: Templates, opt?: EvaluationOptions);
    constructScope(inputTemplateName: string, args: unknown[], allTemplates: Template[]): MemoryInterface;
    protected defaultResult(): string[];
    expandTemplate(templateName: string, scope: unknown): unknown[];
    readonly templateMap: {
        [name: string]: Template;
    };
    readonly templates: Templates;
    visitIfElseBody(ctx: IfElseBodyContext): unknown[];
    visitNormalBody(ctx: NormalBodyContext): unknown[];
    visitNormalTemplateBody(ctx: NormalTemplateBodyContext): unknown[];
    visitNormalTemplateString(ctx: NormalTemplateStringContext): unknown[];
    visitStructuredBody(ctx: StructuredBodyContext): unknown[];
    visitSwitchCaseBody(ctx: SwitchCaseBodyContext): unknown[];
}

// @public (undocumented)
export class ExpressionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    EXPRESSION(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class ExpressionInStructureContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    EXPRESSION_IN_STRUCTURE_BODY(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class Extractor extends AbstractParseTreeVisitor<Map<string, string[]>> implements LGTemplateParserVisitor<Map<string, string[]>> {
    constructor(templates: Template[]);
    protected defaultResult(): Map<string, string[]>;
    extract(): Map<string, string[] | Map<string, string[]>>[];
    // (undocumented)
    readonly templateMap: Record<string, Template>;
    // (undocumented)
    readonly templates: Template[];
    visitIfElseBody(context: IfElseBodyContext): Map<string, string[]>;
    visitNormalTemplateBody(context: NormalTemplateBodyContext): Map<string, string[]>;
    visitStructuredBody(context: StructuredBodyContext): Map<string, string[]>;
    visitSwitchCaseBody(context: SwitchCaseBodyContext): Map<string, string[]>;
}

// @public (undocumented)
export class FileContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    EOF(): TerminalNode;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    paragraph(): ParagraphContext[];
    // (undocumented)
    paragraph(i: number): ParagraphContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export enum FileFormat {
    Binary = "Binary",
    Evaluated = "Evaluated",
    Raw = "Raw"
}

// @public (undocumented)
export class IfConditionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    DASH(): TerminalNode;
    // (undocumented)
    ELSE(): TerminalNode | undefined;
    // (undocumented)
    ELSEIF(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    expression(): ExpressionContext[];
    // (undocumented)
    expression(i: number): ExpressionContext;
    // (undocumented)
    IF(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    TEXT(): TerminalNode[];
    // (undocumented)
    TEXT(i: number): TerminalNode;
    // (undocumented)
    WS(): TerminalNode[];
    // (undocumented)
    WS(i: number): TerminalNode;
}

// @public (undocumented)
export class IfConditionRuleContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    ifCondition(): IfConditionContext;
    // (undocumented)
    normalTemplateBody(): NormalTemplateBodyContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class IfElseBodyContext extends BodyContext {
    constructor(ctx: BodyContext);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    ifElseTemplateBody(): IfElseTemplateBodyContext;
}

// @public (undocumented)
export class IfElseTemplateBodyContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    ifConditionRule(): IfConditionRuleContext[];
    // (undocumented)
    ifConditionRule(i: number): IfConditionRuleContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class ImportDefinitionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    IMPORT(): TerminalNode;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export type ImportResolverDelegate = (lgResource: LGResource, resourceId: string) => LGResource;

// @public (undocumented)
export class KeyValueStructureLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    keyValueStructureValue(): KeyValueStructureValueContext[];
    // (undocumented)
    keyValueStructureValue(i: number): KeyValueStructureValueContext;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRUCTURE_EQUALS(): TerminalNode;
    // (undocumented)
    STRUCTURE_IDENTIFIER(): TerminalNode;
    // (undocumented)
    STRUCTURE_OR_MARK(): TerminalNode[];
    // (undocumented)
    STRUCTURE_OR_MARK(i: number): TerminalNode;
}

// @public (undocumented)
export class KeyValueStructureValueContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(): TerminalNode[];
    // (undocumented)
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(i: number): TerminalNode;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    expressionInStructure(): ExpressionInStructureContext[];
    // (undocumented)
    expressionInStructure(i: number): ExpressionInStructureContext;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    TEXT_IN_STRUCTURE_BODY(): TerminalNode[];
    // (undocumented)
    TEXT_IN_STRUCTURE_BODY(i: number): TerminalNode;
}

// @public
export enum LGCacheScope {
    Global = "global",
    Local = "local",
    None = "none"
}

// @public (undocumented)
export class LGFileLexer extends Lexer {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: CharStream);
    // (undocumented)
    action(_localctx: RuleContext, ruleIndex: number, actionIndex: number): void;
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    static readonly channelNames: string[];
    // (undocumented)
    readonly channelNames: string[];
    // (undocumented)
    static readonly COMMENT = 3;
    // (undocumented)
    static readonly ESCAPE_CHARACTER = 11;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly IMPORT = 4;
    // (undocumented)
    static readonly INLINE_MULTILINE = 6;
    // (undocumented)
    static readonly INVALID_LINE = 9;
    // (undocumented)
    static readonly modeNames: string[];
    // (undocumented)
    readonly modeNames: string[];
    // (undocumented)
    static readonly MULTILINE_MODE = 1;
    // (undocumented)
    static readonly MULTILINE_PREFIX = 7;
    // (undocumented)
    static readonly MULTILINE_SUFFIX = 10;
    // (undocumented)
    static readonly MULTILINE_TEXT = 12;
    // (undocumented)
    static readonly NEWLINE = 1;
    // (undocumented)
    static readonly OPTION = 2;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    startTemplate: boolean;
    // (undocumented)
    static readonly TEMPLATE_BODY = 8;
    // (undocumented)
    static readonly TEMPLATE_NAME_LINE = 5;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
}

// @public (undocumented)
export class LGFileParser extends Parser {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: TokenStream);
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    static readonly COMMENT = 3;
    // (undocumented)
    commentDefinition(): CommentDefinitionContext;
    // (undocumented)
    errorDefinition(): ErrorDefinitionContext;
    // (undocumented)
    static readonly ESCAPE_CHARACTER = 11;
    // (undocumented)
    file(): FileContext;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly IMPORT = 4;
    // (undocumented)
    importDefinition(): ImportDefinitionContext;
    // (undocumented)
    static readonly INLINE_MULTILINE = 6;
    // (undocumented)
    static readonly INVALID_LINE = 9;
    // (undocumented)
    static readonly MULTILINE_PREFIX = 7;
    // (undocumented)
    static readonly MULTILINE_SUFFIX = 10;
    // (undocumented)
    static readonly MULTILINE_TEXT = 12;
    // (undocumented)
    static readonly NEWLINE = 1;
    // (undocumented)
    static readonly OPTION = 2;
    // (undocumented)
    optionDefinition(): OptionDefinitionContext;
    // (undocumented)
    paragraph(): ParagraphContext;
    // (undocumented)
    static readonly RULE_commentDefinition = 2;
    // (undocumented)
    static readonly RULE_errorDefinition = 5;
    // (undocumented)
    static readonly RULE_file = 0;
    // (undocumented)
    static readonly RULE_importDefinition = 3;
    // (undocumented)
    static readonly RULE_optionDefinition = 4;
    // (undocumented)
    static readonly RULE_paragraph = 1;
    // (undocumented)
    static readonly RULE_templateBody = 8;
    // (undocumented)
    static readonly RULE_templateBodyLine = 9;
    // (undocumented)
    static readonly RULE_templateDefinition = 6;
    // (undocumented)
    static readonly RULE_templateNameLine = 7;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    static readonly TEMPLATE_BODY = 8;
    // (undocumented)
    static readonly TEMPLATE_NAME_LINE = 5;
    // (undocumented)
    templateBody(): TemplateBodyContext;
    // (undocumented)
    templateBodyLine(): TemplateBodyLineContext;
    // (undocumented)
    templateDefinition(): TemplateDefinitionContext;
    // (undocumented)
    templateNameLine(): TemplateNameLineContext;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
}

// @public
export interface LGFileParserListener extends ParseTreeListener {
    enterCommentDefinition?: (ctx: CommentDefinitionContext) => void;
    enterErrorDefinition?: (ctx: ErrorDefinitionContext) => void;
    enterFile?: (ctx: FileContext) => void;
    enterImportDefinition?: (ctx: ImportDefinitionContext) => void;
    enterOptionDefinition?: (ctx: OptionDefinitionContext) => void;
    enterParagraph?: (ctx: ParagraphContext) => void;
    enterTemplateBody?: (ctx: TemplateBodyContext) => void;
    enterTemplateBodyLine?: (ctx: TemplateBodyLineContext) => void;
    enterTemplateDefinition?: (ctx: TemplateDefinitionContext) => void;
    enterTemplateNameLine?: (ctx: TemplateNameLineContext) => void;
    exitCommentDefinition?: (ctx: CommentDefinitionContext) => void;
    exitErrorDefinition?: (ctx: ErrorDefinitionContext) => void;
    exitFile?: (ctx: FileContext) => void;
    exitImportDefinition?: (ctx: ImportDefinitionContext) => void;
    exitOptionDefinition?: (ctx: OptionDefinitionContext) => void;
    exitParagraph?: (ctx: ParagraphContext) => void;
    exitTemplateBody?: (ctx: TemplateBodyContext) => void;
    exitTemplateBodyLine?: (ctx: TemplateBodyLineContext) => void;
    exitTemplateDefinition?: (ctx: TemplateDefinitionContext) => void;
    exitTemplateNameLine?: (ctx: TemplateNameLineContext) => void;
}

// @public
export interface LGFileParserVisitor<Result> extends ParseTreeVisitor<Result> {
    visitCommentDefinition?: (ctx: CommentDefinitionContext) => Result;
    visitErrorDefinition?: (ctx: ErrorDefinitionContext) => Result;
    visitFile?: (ctx: FileContext) => Result;
    visitImportDefinition?: (ctx: ImportDefinitionContext) => Result;
    visitOptionDefinition?: (ctx: OptionDefinitionContext) => Result;
    visitParagraph?: (ctx: ParagraphContext) => Result;
    visitTemplateBody?: (ctx: TemplateBodyContext) => Result;
    visitTemplateBodyLine?: (ctx: TemplateBodyLineContext) => Result;
    visitTemplateDefinition?: (ctx: TemplateDefinitionContext) => Result;
    visitTemplateNameLine?: (ctx: TemplateNameLineContext) => Result;
}

// @public
export enum LGLineBreakStyle {
    // (undocumented)
    Default = "default",
    // (undocumented)
    Markdown = "markdown"
}

// @public
export class LGResource {
    constructor(id: string, fullName: string, content: string);
    content: string;
    fullName: string;
    id: string;
}

// @public (undocumented)
export class LGTemplateLexer extends Lexer {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: CharStream);
    // (undocumented)
    action(_localctx: RuleContext, ruleIndex: number, actionIndex: number): void;
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    beginOfStructureProperty: boolean;
    // (undocumented)
    beginOfTemplateBody: boolean;
    // (undocumented)
    beginOfTemplateLine: boolean;
    // (undocumented)
    static readonly CASE = 14;
    // (undocumented)
    static readonly channelNames: string[];
    // (undocumented)
    readonly channelNames: string[];
    // (undocumented)
    static readonly COMMENTS = 3;
    // (undocumented)
    static readonly DASH = 4;
    // (undocumented)
    static readonly DEFAULT = 15;
    // (undocumented)
    static readonly ELSE = 12;
    // (undocumented)
    static readonly ELSEIF = 11;
    // (undocumented)
    static readonly ESCAPE_CHARACTER = 16;
    // (undocumented)
    static readonly ESCAPE_CHARACTER_IN_STRUCTURE_BODY = 31;
    // (undocumented)
    static readonly EXPRESSION = 17;
    // (undocumented)
    static readonly EXPRESSION_IN_STRUCTURE_BODY = 32;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly IF = 10;
    // (undocumented)
    ignoreWS: boolean;
    // (undocumented)
    inMultiline: boolean;
    // (undocumented)
    inStructuredValue: boolean;
    // (undocumented)
    static readonly INVALID_TOKEN = 6;
    // (undocumented)
    static readonly LEFT_SQUARE_BRACKET = 5;
    // (undocumented)
    static readonly modeNames: string[];
    // (undocumented)
    readonly modeNames: string[];
    // (undocumented)
    static readonly MULTILINE_MODE = 2;
    // (undocumented)
    static readonly MULTILINE_PREFIX = 8;
    // (undocumented)
    static readonly MULTILINE_SUFFIX = 19;
    // (undocumented)
    static readonly NEWLINE = 2;
    // (undocumented)
    static readonly NEWLINE_IN_BODY = 9;
    // (undocumented)
    static readonly NEWLINE_IN_STRUCTURE_NAME = 21;
    // (undocumented)
    static readonly NORMAL_TEMPLATE_BODY_MODE = 1;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    static readonly STRUCTURE_BODY_MODE = 4;
    // (undocumented)
    static readonly STRUCTURE_EQUALS = 29;
    // (undocumented)
    static readonly STRUCTURE_IDENTIFIER = 28;
    // (undocumented)
    static readonly STRUCTURE_NAME = 22;
    // (undocumented)
    static readonly STRUCTURE_NAME_MODE = 3;
    // (undocumented)
    static readonly STRUCTURE_OR_MARK = 30;
    // (undocumented)
    static readonly STRUCTURED_BODY_END = 27;
    // (undocumented)
    static readonly STRUCTURED_COMMENTS = 24;
    // (undocumented)
    static readonly STRUCTURED_NEWLINE = 26;
    // (undocumented)
    static readonly SWITCH = 13;
    // (undocumented)
    static readonly TEXT = 18;
    // (undocumented)
    static readonly TEXT_IN_STRUCTURE_BODY = 33;
    // (undocumented)
    static readonly TEXT_IN_STRUCTURE_NAME = 23;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
    // (undocumented)
    static readonly WS = 1;
    // (undocumented)
    static readonly WS_IN_BODY = 7;
    // (undocumented)
    static readonly WS_IN_STRUCTURE_BODY = 25;
    // (undocumented)
    static readonly WS_IN_STRUCTURE_NAME = 20;
}

// @public (undocumented)
export class LGTemplateParser extends Parser {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: TokenStream);
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    body(): BodyContext;
    // (undocumented)
    static readonly CASE = 14;
    // (undocumented)
    static readonly COMMENTS = 3;
    // (undocumented)
    static readonly DASH = 4;
    // (undocumented)
    static readonly DEFAULT = 15;
    // (undocumented)
    static readonly ELSE = 12;
    // (undocumented)
    static readonly ELSEIF = 11;
    // (undocumented)
    errorStructuredName(): ErrorStructuredNameContext;
    // (undocumented)
    errorStructureLine(): ErrorStructureLineContext;
    // (undocumented)
    errorTemplateString(): ErrorTemplateStringContext;
    // (undocumented)
    static readonly ESCAPE_CHARACTER = 16;
    // (undocumented)
    static readonly ESCAPE_CHARACTER_IN_STRUCTURE_BODY = 31;
    // (undocumented)
    static readonly EXPRESSION = 17;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    static readonly EXPRESSION_IN_STRUCTURE_BODY = 32;
    // (undocumented)
    expressionInStructure(): ExpressionInStructureContext;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly IF = 10;
    // (undocumented)
    ifCondition(): IfConditionContext;
    // (undocumented)
    ifConditionRule(): IfConditionRuleContext;
    // (undocumented)
    ifElseTemplateBody(): IfElseTemplateBodyContext;
    // (undocumented)
    static readonly INVALID_TOKEN = 6;
    // (undocumented)
    keyValueStructureLine(): KeyValueStructureLineContext;
    // (undocumented)
    keyValueStructureValue(): KeyValueStructureValueContext;
    // (undocumented)
    static readonly LEFT_SQUARE_BRACKET = 5;
    // (undocumented)
    static readonly MULTILINE_PREFIX = 8;
    // (undocumented)
    static readonly MULTILINE_SUFFIX = 19;
    // (undocumented)
    static readonly NEWLINE = 2;
    // (undocumented)
    static readonly NEWLINE_IN_BODY = 9;
    // (undocumented)
    static readonly NEWLINE_IN_STRUCTURE_NAME = 21;
    // (undocumented)
    normalTemplateBody(): NormalTemplateBodyContext;
    // (undocumented)
    normalTemplateString(): NormalTemplateStringContext;
    // (undocumented)
    static readonly RULE_body = 1;
    // (undocumented)
    static readonly RULE_errorStructuredName = 4;
    // (undocumented)
    static readonly RULE_errorStructureLine = 6;
    // (undocumented)
    static readonly RULE_errorTemplateString = 13;
    // (undocumented)
    static readonly RULE_expression = 20;
    // (undocumented)
    static readonly RULE_expressionInStructure = 21;
    // (undocumented)
    static readonly RULE_ifCondition = 16;
    // (undocumented)
    static readonly RULE_ifConditionRule = 15;
    // (undocumented)
    static readonly RULE_ifElseTemplateBody = 14;
    // (undocumented)
    static readonly RULE_keyValueStructureLine = 7;
    // (undocumented)
    static readonly RULE_keyValueStructureValue = 8;
    // (undocumented)
    static readonly RULE_normalTemplateBody = 10;
    // (undocumented)
    static readonly RULE_normalTemplateString = 12;
    // (undocumented)
    static readonly RULE_structuredBodyContentLine = 5;
    // (undocumented)
    static readonly RULE_structuredBodyEndLine = 9;
    // (undocumented)
    static readonly RULE_structuredBodyNameLine = 3;
    // (undocumented)
    static readonly RULE_structuredTemplateBody = 2;
    // (undocumented)
    static readonly RULE_switchCaseRule = 18;
    // (undocumented)
    static readonly RULE_switchCaseStat = 19;
    // (undocumented)
    static readonly RULE_switchCaseTemplateBody = 17;
    // (undocumented)
    static readonly RULE_template = 0;
    // (undocumented)
    static readonly RULE_templateString = 11;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    static readonly STRUCTURE_EQUALS = 29;
    // (undocumented)
    static readonly STRUCTURE_IDENTIFIER = 28;
    // (undocumented)
    static readonly STRUCTURE_NAME = 22;
    // (undocumented)
    static readonly STRUCTURE_OR_MARK = 30;
    // (undocumented)
    static readonly STRUCTURED_BODY_END = 27;
    // (undocumented)
    static readonly STRUCTURED_COMMENTS = 24;
    // (undocumented)
    static readonly STRUCTURED_NEWLINE = 26;
    // (undocumented)
    structuredBodyContentLine(): StructuredBodyContentLineContext;
    // (undocumented)
    structuredBodyEndLine(): StructuredBodyEndLineContext;
    // (undocumented)
    structuredBodyNameLine(): StructuredBodyNameLineContext;
    // (undocumented)
    structuredTemplateBody(): StructuredTemplateBodyContext;
    // (undocumented)
    static readonly SWITCH = 13;
    // (undocumented)
    switchCaseRule(): SwitchCaseRuleContext;
    // (undocumented)
    switchCaseStat(): SwitchCaseStatContext;
    // (undocumented)
    switchCaseTemplateBody(): SwitchCaseTemplateBodyContext;
    // (undocumented)
    template(): TemplateContext;
    // (undocumented)
    templateString(): TemplateStringContext;
    // (undocumented)
    static readonly TEXT = 18;
    // (undocumented)
    static readonly TEXT_IN_STRUCTURE_BODY = 33;
    // (undocumented)
    static readonly TEXT_IN_STRUCTURE_NAME = 23;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
    // (undocumented)
    static readonly WS = 1;
    // (undocumented)
    static readonly WS_IN_BODY = 7;
    // (undocumented)
    static readonly WS_IN_STRUCTURE_BODY = 25;
    // (undocumented)
    static readonly WS_IN_STRUCTURE_NAME = 20;
}

// @public
export interface LGTemplateParserListener extends ParseTreeListener {
    enterBody?: (ctx: BodyContext) => void;
    enterErrorStructuredName?: (ctx: ErrorStructuredNameContext) => void;
    enterErrorStructureLine?: (ctx: ErrorStructureLineContext) => void;
    enterErrorTemplateString?: (ctx: ErrorTemplateStringContext) => void;
    enterExpression?: (ctx: ExpressionContext) => void;
    enterExpressionInStructure?: (ctx: ExpressionInStructureContext) => void;
    enterIfCondition?: (ctx: IfConditionContext) => void;
    enterIfConditionRule?: (ctx: IfConditionRuleContext) => void;
    enterIfElseBody?: (ctx: IfElseBodyContext) => void;
    enterIfElseTemplateBody?: (ctx: IfElseTemplateBodyContext) => void;
    enterKeyValueStructureLine?: (ctx: KeyValueStructureLineContext) => void;
    enterKeyValueStructureValue?: (ctx: KeyValueStructureValueContext) => void;
    enterNormalBody?: (ctx: NormalBodyContext) => void;
    enterNormalTemplateBody?: (ctx: NormalTemplateBodyContext) => void;
    enterNormalTemplateString?: (ctx: NormalTemplateStringContext) => void;
    enterStructuredBody?: (ctx: StructuredBodyContext) => void;
    enterStructuredBodyContentLine?: (ctx: StructuredBodyContentLineContext) => void;
    enterStructuredBodyEndLine?: (ctx: StructuredBodyEndLineContext) => void;
    enterStructuredBodyNameLine?: (ctx: StructuredBodyNameLineContext) => void;
    enterStructuredTemplateBody?: (ctx: StructuredTemplateBodyContext) => void;
    enterSwitchCaseBody?: (ctx: SwitchCaseBodyContext) => void;
    enterSwitchCaseRule?: (ctx: SwitchCaseRuleContext) => void;
    enterSwitchCaseStat?: (ctx: SwitchCaseStatContext) => void;
    enterSwitchCaseTemplateBody?: (ctx: SwitchCaseTemplateBodyContext) => void;
    enterTemplate?: (ctx: TemplateContext) => void;
    enterTemplateString?: (ctx: TemplateStringContext) => void;
    exitBody?: (ctx: BodyContext) => void;
    exitErrorStructuredName?: (ctx: ErrorStructuredNameContext) => void;
    exitErrorStructureLine?: (ctx: ErrorStructureLineContext) => void;
    exitErrorTemplateString?: (ctx: ErrorTemplateStringContext) => void;
    exitExpression?: (ctx: ExpressionContext) => void;
    exitExpressionInStructure?: (ctx: ExpressionInStructureContext) => void;
    exitIfCondition?: (ctx: IfConditionContext) => void;
    exitIfConditionRule?: (ctx: IfConditionRuleContext) => void;
    exitIfElseBody?: (ctx: IfElseBodyContext) => void;
    exitIfElseTemplateBody?: (ctx: IfElseTemplateBodyContext) => void;
    exitKeyValueStructureLine?: (ctx: KeyValueStructureLineContext) => void;
    exitKeyValueStructureValue?: (ctx: KeyValueStructureValueContext) => void;
    exitNormalBody?: (ctx: NormalBodyContext) => void;
    exitNormalTemplateBody?: (ctx: NormalTemplateBodyContext) => void;
    exitNormalTemplateString?: (ctx: NormalTemplateStringContext) => void;
    exitStructuredBody?: (ctx: StructuredBodyContext) => void;
    exitStructuredBodyContentLine?: (ctx: StructuredBodyContentLineContext) => void;
    exitStructuredBodyEndLine?: (ctx: StructuredBodyEndLineContext) => void;
    exitStructuredBodyNameLine?: (ctx: StructuredBodyNameLineContext) => void;
    exitStructuredTemplateBody?: (ctx: StructuredTemplateBodyContext) => void;
    exitSwitchCaseBody?: (ctx: SwitchCaseBodyContext) => void;
    exitSwitchCaseRule?: (ctx: SwitchCaseRuleContext) => void;
    exitSwitchCaseStat?: (ctx: SwitchCaseStatContext) => void;
    exitSwitchCaseTemplateBody?: (ctx: SwitchCaseTemplateBodyContext) => void;
    exitTemplate?: (ctx: TemplateContext) => void;
    exitTemplateString?: (ctx: TemplateStringContext) => void;
}

// @public
export interface LGTemplateParserVisitor<Result> extends ParseTreeVisitor<Result> {
    visitBody?: (ctx: BodyContext) => Result;
    visitErrorStructuredName?: (ctx: ErrorStructuredNameContext) => Result;
    visitErrorStructureLine?: (ctx: ErrorStructureLineContext) => Result;
    visitErrorTemplateString?: (ctx: ErrorTemplateStringContext) => Result;
    visitExpression?: (ctx: ExpressionContext) => Result;
    visitExpressionInStructure?: (ctx: ExpressionInStructureContext) => Result;
    visitIfCondition?: (ctx: IfConditionContext) => Result;
    visitIfConditionRule?: (ctx: IfConditionRuleContext) => Result;
    visitIfElseBody?: (ctx: IfElseBodyContext) => Result;
    visitIfElseTemplateBody?: (ctx: IfElseTemplateBodyContext) => Result;
    visitKeyValueStructureLine?: (ctx: KeyValueStructureLineContext) => Result;
    visitKeyValueStructureValue?: (ctx: KeyValueStructureValueContext) => Result;
    visitNormalBody?: (ctx: NormalBodyContext) => Result;
    visitNormalTemplateBody?: (ctx: NormalTemplateBodyContext) => Result;
    visitNormalTemplateString?: (ctx: NormalTemplateStringContext) => Result;
    visitStructuredBody?: (ctx: StructuredBodyContext) => Result;
    visitStructuredBodyContentLine?: (ctx: StructuredBodyContentLineContext) => Result;
    visitStructuredBodyEndLine?: (ctx: StructuredBodyEndLineContext) => Result;
    visitStructuredBodyNameLine?: (ctx: StructuredBodyNameLineContext) => Result;
    visitStructuredTemplateBody?: (ctx: StructuredTemplateBodyContext) => Result;
    visitSwitchCaseBody?: (ctx: SwitchCaseBodyContext) => Result;
    visitSwitchCaseRule?: (ctx: SwitchCaseRuleContext) => Result;
    visitSwitchCaseStat?: (ctx: SwitchCaseStatContext) => Result;
    visitSwitchCaseTemplateBody?: (ctx: SwitchCaseTemplateBodyContext) => Result;
    visitTemplate?: (ctx: TemplateContext) => Result;
    visitTemplateString?: (ctx: TemplateStringContext) => Result;
}

// @public
export class MultiLanguageLG {
    constructor(templatesPerLocale: Map<string, Templates> | undefined, filePerLocale: Map<string, string> | undefined, defaultLanguage?: string);
    generate(template: string, data?: object, locale?: string): any;
    // (undocumented)
    languagePolicy: Map<string, string[]>;
    // (undocumented)
    lgPerLocale: Map<string, Templates>;
    }

// @public (undocumented)
export class NormalBodyContext extends BodyContext {
    constructor(ctx: BodyContext);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    normalTemplateBody(): NormalTemplateBodyContext;
}

// @public (undocumented)
export class NormalTemplateBodyContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    templateString(): TemplateStringContext[];
    // (undocumented)
    templateString(i: number): TemplateStringContext;
}

// @public (undocumented)
export class NormalTemplateStringContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    DASH(): TerminalNode;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    ESCAPE_CHARACTER(): TerminalNode[];
    // (undocumented)
    ESCAPE_CHARACTER(i: number): TerminalNode;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    expression(): ExpressionContext[];
    // (undocumented)
    expression(i: number): ExpressionContext;
    // (undocumented)
    MULTILINE_PREFIX(): TerminalNode | undefined;
    // (undocumented)
    MULTILINE_SUFFIX(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    TEXT(): TerminalNode[];
    // (undocumented)
    TEXT(i: number): TerminalNode;
}

// @public (undocumented)
export class OptionDefinitionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    OPTION(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class ParagraphContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    commentDefinition(): CommentDefinitionContext | undefined;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    EOF(): TerminalNode | undefined;
    // (undocumented)
    errorDefinition(): ErrorDefinitionContext | undefined;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    importDefinition(): ImportDefinitionContext | undefined;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    optionDefinition(): OptionDefinitionContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    templateDefinition(): TemplateDefinitionContext | undefined;
}

// @public
export class Position {
    constructor(line: number, character: number);
    // (undocumented)
    character: number;
    // (undocumented)
    line: number;
    // (undocumented)
    toString: () => string;
}

// @public
class Range_2 {
    constructor(start: Position, end: Position);
    constructor(startLine: number, startChar: number, endLine: number, endChar: number);
    // (undocumented)
    static readonly DefaultRange: Range_2;
    // (undocumented)
    end: Position;
    // (undocumented)
    start: Position;
    // (undocumented)
    toString: () => string;
}

export { Range_2 as Range }

// @public
export class StaticChecker extends AbstractParseTreeVisitor<Diagnostic[]> implements LGTemplateParserVisitor<Diagnostic[]> {
    constructor(templates: Templates);
    check(): Diagnostic[];
    protected defaultResult(): Diagnostic[];
    visitIfElseBody(context: IfElseBodyContext): Diagnostic[];
    visitNormalTemplateBody(context: NormalTemplateBodyContext): Diagnostic[];
    visitNormalTemplateString(context: NormalTemplateStringContext): Diagnostic[];
    visitStructuredTemplateBody(context: StructuredTemplateBodyContext): Diagnostic[];
    visitSwitchCaseBody(context: SwitchCaseBodyContext): Diagnostic[];
}

// @public (undocumented)
export class StructuredBodyContentLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    expressionInStructure(): ExpressionInStructureContext | undefined;
    // (undocumented)
    keyValueStructureLine(): KeyValueStructureLineContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class StructuredBodyContext extends BodyContext {
    constructor(ctx: BodyContext);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    structuredTemplateBody(): StructuredTemplateBodyContext;
}

// @public (undocumented)
export class StructuredBodyEndLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRUCTURED_BODY_END(): TerminalNode;
}

// @public (undocumented)
export class StructuredBodyNameLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    errorStructuredName(): ErrorStructuredNameContext | undefined;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    LEFT_SQUARE_BRACKET(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRUCTURE_NAME(): TerminalNode | undefined;
}

// @public (undocumented)
export class StructuredTemplateBodyContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    errorStructureLine(): ErrorStructureLineContext[];
    // (undocumented)
    errorStructureLine(i: number): ErrorStructureLineContext;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRUCTURED_NEWLINE(): TerminalNode[];
    // (undocumented)
    STRUCTURED_NEWLINE(i: number): TerminalNode;
    // (undocumented)
    structuredBodyContentLine(): StructuredBodyContentLineContext[];
    // (undocumented)
    structuredBodyContentLine(i: number): StructuredBodyContentLineContext;
    // (undocumented)
    structuredBodyEndLine(): StructuredBodyEndLineContext | undefined;
    // (undocumented)
    structuredBodyNameLine(): StructuredBodyNameLineContext;
}

// @public (undocumented)
export class SwitchCaseBodyContext extends BodyContext {
    constructor(ctx: BodyContext);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    switchCaseTemplateBody(): SwitchCaseTemplateBodyContext;
}

// @public (undocumented)
export class SwitchCaseRuleContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    normalTemplateBody(): NormalTemplateBodyContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    switchCaseStat(): SwitchCaseStatContext;
}

// @public (undocumented)
export class SwitchCaseStatContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    CASE(): TerminalNode | undefined;
    // (undocumented)
    DASH(): TerminalNode;
    // (undocumented)
    DEFAULT(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    expression(): ExpressionContext[];
    // (undocumented)
    expression(i: number): ExpressionContext;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    SWITCH(): TerminalNode | undefined;
    // (undocumented)
    TEXT(): TerminalNode[];
    // (undocumented)
    TEXT(i: number): TerminalNode;
    // (undocumented)
    WS(): TerminalNode[];
    // (undocumented)
    WS(i: number): TerminalNode;
}

// @public (undocumented)
export class SwitchCaseTemplateBodyContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    switchCaseRule(): SwitchCaseRuleContext[];
    // (undocumented)
    switchCaseRule(i: number): SwitchCaseRuleContext;
}

// @public
export class Template {
    constructor(templatename: string, parameters: string[], templatebody: string, sourceRange: SourceRange);
    body: string;
    name: string;
    parameters: string[];
    properties?: Record<string, unknown>;
    // Warning: (ae-forgotten-export) The symbol "SourceRange" needs to be exported by the entry point index.d.ts
    sourceRange: SourceRange;
    templateBodyParseTree: BodyContext;
    toString(): string;
}

// @public (undocumented)
export class TemplateBodyContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    templateBodyLine(): TemplateBodyLineContext[];
    // (undocumented)
    templateBodyLine(i: number): TemplateBodyLineContext;
}

// @public (undocumented)
export class TemplateBodyLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    ESCAPE_CHARACTER(): TerminalNode[];
    // (undocumented)
    ESCAPE_CHARACTER(i: number): TerminalNode;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    INLINE_MULTILINE(): TerminalNode | undefined;
    // (undocumented)
    MULTILINE_PREFIX(): TerminalNode | undefined;
    // (undocumented)
    MULTILINE_SUFFIX(): TerminalNode | undefined;
    // (undocumented)
    MULTILINE_TEXT(): TerminalNode[];
    // (undocumented)
    MULTILINE_TEXT(i: number): TerminalNode;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    TEMPLATE_BODY(): TerminalNode | undefined;
}

// @public (undocumented)
export class TemplateContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    body(): BodyContext;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    EOF(): TerminalNode;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class TemplateDefinitionContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    templateBody(): TemplateBodyContext;
    // (undocumented)
    templateNameLine(): TemplateNameLineContext;
}

// @public
export class TemplateErrors {
    // (undocumented)
    static readonly argumentMismatch: (templateName: string, expectedCount: number, actualCount: number) => string;
    // (undocumented)
    static readonly duplicatedTemplateInDiffTemplate: (templateName: string, source: string) => string;
    // (undocumented)
    static readonly duplicatedTemplateInSameTemplate: (templateName: string) => string;
    // (undocumented)
    static readonly emptyStrucContent: string;
    // (undocumented)
    static readonly errorExpression: (refFullText: string, templateName: string, prefixText: string) => string;
    // (undocumented)
    static readonly expressionParseError: (exp: string) => string;
    // (undocumented)
    static readonly extraExpressionInCondition: string;
    // (undocumented)
    static readonly extraExpressionInSwitchCase: string;
    // (undocumented)
    static readonly importFormatError: string;
    // (undocumented)
    static readonly invalidExpressionInCondition: string;
    // (undocumented)
    static readonly invalidExpressionInSwiathCase: string;
    // (undocumented)
    static readonly invalidMemory: string;
    // (undocumented)
    static readonly invalidMiddleInCondition: string;
    // (undocumented)
    static readonly invalidParameter: (invalidParameter: string) => string;
    // (undocumented)
    static readonly invalidStatementInMiddlerOfSwitchCase: string;
    // (undocumented)
    static readonly invalidStrucBody: (invalidBody: string) => string;
    // (undocumented)
    static readonly invalidStrucName: (invalidName: string) => string;
    // (undocumented)
    static readonly invalidTemplateBody: string;
    // (undocumented)
    static readonly invalidTemplateName: (invalidTemplateName: string) => string;
    // (undocumented)
    static readonly invalidTemplateNameType: string;
    // (undocumented)
    static readonly invalidWhitespaceInCondition: string;
    // (undocumented)
    static readonly invalidWhitespaceInSwitchCase: string;
    // (undocumented)
    static readonly loopDetected: string;
    // (undocumented)
    static readonly missingCaseInSwitchCase: string;
    // (undocumented)
    static readonly missingStrucEnd: string;
    // (undocumented)
    static readonly missingTemplateBodyInCondition: string;
    // (undocumented)
    static readonly missingTemplateBodyInSwitchCase: string;
    // (undocumented)
    static readonly multipleIfInCondition: string;
    // (undocumented)
    static readonly multipleSwithStatementInSwitchCase: string;
    // (undocumented)
    static readonly noCloseBracket: string;
    // (undocumented)
    static readonly noEndingInMultiline: string;
    // (undocumented)
    static readonly noTemplate: string;
    // (undocumented)
    static readonly noTemplateBody: (templateName: string) => string;
    // (undocumented)
    static readonly notEndWithDefaultInSwitchCase: string;
    // (undocumented)
    static readonly notEndWithElseInCondition: string;
    // (undocumented)
    static readonly notStartWithIfInCondition: string;
    // (undocumented)
    static readonly notStartWithSwitchInSwitchCase: string;
    // (undocumented)
    static readonly nullExpression: (expression: string) => string;
    // (undocumented)
    static readonly staticFailure: string;
    // (undocumented)
    static readonly syntaxError: (unexpectedContent: string) => string;
    // (undocumented)
    static readonly templateExist: (templateName: string) => string;
    // (undocumented)
    static readonly templateNotExist: (templateName: string) => string;
}

// @public
export class TemplateException extends Error {
    constructor(m: string, diagnostics: Diagnostic[]);
    getDiagnostic(): Diagnostic[];
}

// @public
export class TemplateExtensions {
    static convertToRange(context: ParserRuleContext, lineOffset?: number): Range_2;
    static evalEscape(exp: string): string;
    static getPrefixErrorMessage(context: NormalTemplateStringContext): string;
    static isPureExpression(ctx: KeyValueStructureValueContext): boolean;
    static newGuid(): string;
    static normalizePath(ambiguousPath: string): string;
    static readLine(input: string): string[];
    static trimExpression(expression: string): string;
}

// @public
export class TemplateImport {
    constructor(description: string, id: string, sourceRange: SourceRange, alias?: string);
    alias?: string;
    description: string;
    id: string;
    sourceRange: SourceRange;
    // (undocumented)
    toString: () => string;
}

// @public (undocumented)
export class TemplateNameLineContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGFileParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGFileParserListener): void;
    // (undocumented)
    exitRule(listener: LGFileParserListener): void;
    // (undocumented)
    NEWLINE(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    TEMPLATE_NAME_LINE(): TerminalNode;
}

// @public
export class Templates implements Iterable<Template> {
    [Symbol.iterator](): Iterator<Template>;
    constructor(items?: Template[], imports?: TemplateImport[], diagnostics?: Diagnostic[], references?: Templates[], content?: string, id?: string, expressionParser?: ExpressionParser, importResolverDelegate?: ImportResolverDelegate, options?: string[], source?: string, namedReferences?: Record<string, Templates>);
    addTemplate(templateName: string, parameters: string[], templateBody: string): Templates;
    readonly allDiagnostics: Diagnostic[];
    readonly allTemplates: Template[];
    analyzeTemplate(templateName: string, analyzerOptions?: AnalyzerOptions): AnalyzerResult;
    content: string;
    deleteTemplate(templateName: string): Templates;
    diagnostics: Diagnostic[];
    static enableFromFile: boolean;
    evaluate(templateName: string, scope?: object, opt?: EvaluationOptions): any;
    evaluateText(inlineStr: string, scope?: object, opt?: EvaluationOptions): any;
    expandTemplate(templateName: string, scope?: object, opt?: EvaluationOptions): any[];
    expressionParser: ExpressionParser;
    id: string;
    importResolver: ImportResolverDelegate;
    imports: TemplateImport[];
    static readonly inlineTemplateIdPrefix: string;
    readonly lgOptions: EvaluationOptions;
    namedReferences: Record<string, Templates>;
    readonly namespace: string;
    options: string[];
    static parseFile(filePath: string, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    static parseResource(resource: LGResource, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    // @deprecated
    static parseText(content: string, id?: string, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    push(...args: Template[]): void;
    references: Templates[];
    source: string;
    toArray(): Template[];
    toString(): string;
    updateTemplate(templateName: string, newTemplateName: string, parameters: string[], templateBody: string): Templates;
}

// @public
export class TemplatesParser {
    static antlrParseTemplates(resource: LGResource): FileContext;
    static defaultFileResolver(resource: LGResource, resourceId: string): LGResource;
    static readonly importRegex: RegExp;
    static readonly inlineContentId: string;
    static readonly optionRegex: RegExp;
    static parseFile(filePath: string, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    static parseResource(resource: LGResource, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    // @deprecated
    static parseText(content: string, id?: string, importResolver?: ImportResolverDelegate, expressionParser?: ExpressionParser): Templates;
    static parseTextWithRef(content: string, originalTemplates: Templates): Templates;
    }

// @public
export class TemplatesTransformer extends AbstractParseTreeVisitor<void> implements LGTemplateParserVisitor<void> {
    constructor(templates: Templates);
    protected defaultResult(): void;
    transform(parseTree: ParseTree): Templates;
    visitErrorDefinition(context: ErrorDefinitionContext): void;
    visitImportDefinition(context: ImportDefinitionContext): void;
    visitOptionDefinition(context: OptionDefinitionContext): void;
    visitTemplateDefinition(context: TemplateDefinitionContext): void;
}

// @public (undocumented)
export class TemplateStringContext extends ParserRuleContext_2 {
    constructor(parent: ParserRuleContext_2 | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    errorTemplateString(): ErrorTemplateStringContext | undefined;
    // (undocumented)
    exitRule(listener: LGTemplateParserListener): void;
    // (undocumented)
    normalTemplateString(): NormalTemplateStringContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}


// (No @packageDocumentation comment for this package)

```
