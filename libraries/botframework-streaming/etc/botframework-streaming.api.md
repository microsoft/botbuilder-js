## API Report File for "botframework-streaming"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { Duplex } from 'stream';
import { DuplexOptions } from 'stream';
import { Socket } from 'net';
import { default as WebSocket_2 } from 'ws';

// @public
export class ContentStream {
    // Warning: (ae-forgotten-export) The symbol "PayloadAssembler" needs to be exported by the entry point index.d.ts
    constructor(id: string, assembler: PayloadAssembler);
    cancel(): void;
    // Warning: (ae-forgotten-export) The symbol "PayloadTypes" needs to be exported by the entry point index.d.ts
    get contentType(): string | PayloadTypes;
    getStream(): SubscribableStream;
    // (undocumented)
    id: string;
    get length(): number;
    readAsJson<T>(): Promise<T>;
    readAsString(): Promise<string>;
}

// @public
export class HttpContent {
    constructor(headers: IHttpContentHeaders, stream: SubscribableStream);
    getStream(): SubscribableStream;
    // Warning: (ae-forgotten-export) The symbol "IHttpContentHeaders" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    headers: IHttpContentHeaders;
}

// @public
export interface INodeBuffer extends Uint8Array {
    // (undocumented)
    compare(otherBuffer: Uint8Array, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;
    // (undocumented)
    constructor: any;
    // (undocumented)
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    // (undocumented)
    equals(otherBuffer: Uint8Array): boolean;
    // (undocumented)
    fill(value: any, offset?: number, end?: number): this;
    // (undocumented)
    includes(value: string | number | this, byteOffset?: number, encoding?: string): boolean;
    // (undocumented)
    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;
    // (undocumented)
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;
    // (undocumented)
    readDoubleBE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readDoubleLE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readFloatBE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readFloatLE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt16BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt16LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt32BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt32LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt8(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt16BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt16LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt32BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt32LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt8(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    swap16(): this;
    // (undocumented)
    swap32(): this;
    // (undocumented)
    swap64(): this;
    // (undocumented)
    toJSON(): {
        type: 'Buffer';
        data: any[];
    };
    // (undocumented)
    toString(encoding?: string, start?: number, end?: number): string;
    // (undocumented)
    write(string: string, offset?: number, length?: number, encoding?: string): number;
    // (undocumented)
    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt8(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt8(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
}

// @public
export interface INodeDuplex extends Duplex {
    // (undocumented)
    on(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: 'data', listener: (chunk: INodeBuffer) => void): this;
}

// @public
export interface INodeIncomingMessage {
    headers?: any;
    method?: any;
}

// @public
export interface INodeSocket extends Socket {
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: 'data', listener: (data: INodeBuffer) => void): this;
}

// @public
export interface IReceiveRequest {
    path?: string;
    streams: ContentStream[];
    verb?: string;
}

// @public
export interface IReceiveResponse {
    // (undocumented)
    statusCode?: number;
    // (undocumented)
    streams: ContentStream[];
}

// @public (undocumented)
export interface ISocket {
    // (undocumented)
    close(): any;
    // (undocumented)
    connect(serverAddress: string): Promise<void>;
    // (undocumented)
    isConnected: boolean;
    // (undocumented)
    setOnCloseHandler(handler: (x: any) => void): any;
    // (undocumented)
    setOnErrorHandler(handler: (x: any) => void): any;
    // (undocumented)
    setOnMessageHandler(handler: (x: any) => void): any;
    // (undocumented)
    write(buffer: INodeBuffer): any;
}

// @public
export interface IStreamingTransportClient {
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): void;
    // (undocumented)
    send(request: StreamingRequest): Promise<IReceiveResponse>;
}

// @public
export interface IStreamingTransportServer {
    // (undocumented)
    disconnect(): void;
    // (undocumented)
    isConnected?: boolean;
    // (undocumented)
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    // (undocumented)
    start(onListen?: () => void): Promise<string>;
}

// @public
export class NamedPipeClient implements IStreamingTransportClient {
    constructor(baseName: string, requestHandler?: RequestHandler, autoReconnect?: boolean);
    connect(): Promise<void>;
    disconnect(): void;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
}

// @public
export class NamedPipeServer implements IStreamingTransportServer {
    constructor(baseName: string, requestHandler?: RequestHandler, autoReconnect?: boolean);
    disconnect(): void;
    get isConnected(): boolean;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    start(onListen?: () => void): Promise<string>;
}

// @public
export class NodeWebSocket implements ISocket {
    constructor(wsSocket?: WebSocket_2);
    close(code?: number, data?: string): void;
    connect(serverAddressOrHostName: string, port?: number): Promise<void>;
    create(req: INodeIncomingMessage, socket: INodeSocket, head: INodeBuffer): Promise<void>;
    get isConnected(): boolean;
    setOnCloseHandler(handler: (x: any) => void): void;
    setOnErrorHandler(handler: (x: any) => void): void;
    setOnMessageHandler(handler: (x: any) => void): void;
    write(buffer: INodeBuffer): void;
    // (undocumented)
    protected wsServer: WebSocket_2.Server;
}

// @public
export class NodeWebSocketFactory extends NodeWebSocketFactoryBase {
    constructor();
    createWebSocket(req: INodeIncomingMessage, socket: INodeSocket, head: INodeBuffer): Promise<NodeWebSocket>;
}

// @public
export abstract class NodeWebSocketFactoryBase {
    // (undocumented)
    abstract createWebSocket(req: INodeIncomingMessage, socket: INodeSocket, head: INodeBuffer): Promise<ISocket>;
}

// @public
export abstract class RequestHandler {
    abstract processRequest(request: IReceiveRequest): Promise<StreamingResponse>;
}

// @public
export class StreamingRequest {
    addStream(content: HttpContent): void;
    static create(method: string, path?: string, body?: HttpContent): StreamingRequest;
    path: string;
    setBody(body: any): void;
    // Warning: (ae-forgotten-export) The symbol "HttpContentStream" needs to be exported by the entry point index.d.ts
    streams: HttpContentStream[];
    verb: string;
}

// @public
export class StreamingResponse {
    addStream(content: HttpContent): void;
    static create(statusCode: number, body?: HttpContent): StreamingResponse;
    setBody(body: any): void;
    // (undocumented)
    statusCode: number;
    // (undocumented)
    streams: HttpContentStream[];
}

// @public
export class SubscribableStream extends Duplex {
    constructor(options?: DuplexOptions);
    // (undocumented)
    length: number;
    _read(size: number): void;
    subscribe(onData: (chunk: any) => void): void;
    _write(chunk: any, _encoding: string, callback: (error?: Error | null) => void): void;
}

// @public
export class WebSocketClient implements IStreamingTransportClient {
    constructor({ url, requestHandler, disconnectionHandler, }: {
        url: string;
        requestHandler: RequestHandler;
        disconnectionHandler: (message: string) => void;
    });
    connect(): Promise<void>;
    disconnect(): void;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
}

// @public
export class WebSocketServer implements IStreamingTransportServer {
    constructor(socket: ISocket, requestHandler?: RequestHandler);
    disconnect(): void;
    get isConnected(): boolean;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    start(): Promise<string>;
}

// (No @packageDocumentation comment for this package)

```
