## API Report File for "botframework-streaming"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Duplex } from 'stream-browserify';
import { DuplexOptions } from 'stream-browserify';
import * as WebSocket from 'ws';

// @public (undocumented)
export class ContentStream {
    // Warning: (ae-forgotten-export) The symbol "PayloadAssembler" needs to be exported by the entry point index.d.ts
    constructor(id: string, assembler: PayloadAssembler);
    // (undocumented)
    cancel(): void;
    // (undocumented)
    readonly contentType: string;
    // (undocumented)
    getStream(): SubscribableStream;
    // (undocumented)
    id: string;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    readAsJson<T>(): Promise<T>;
    // (undocumented)
    readAsString(): Promise<string>;
    }

// @public (undocumented)
export class HttpContent {
    constructor(headers: IHttpContentHeaders, stream: SubscribableStream);
    // (undocumented)
    getStream(): SubscribableStream;
    // Warning: (ae-forgotten-export) The symbol "IHttpContentHeaders" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    headers: IHttpContentHeaders;
    }

// @public
export interface INodeBuffer extends Uint8Array {
    // (undocumented)
    compare(otherBuffer: Uint8Array, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;
    // (undocumented)
    constructor: any;
    // (undocumented)
    copy(targetBuffer: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
    // (undocumented)
    entries(): IterableIterator<[number, number]>;
    // (undocumented)
    equals(otherBuffer: Uint8Array): boolean;
    // (undocumented)
    fill(value: any, offset?: number, end?: number): this;
    // (undocumented)
    includes(value: string | number | this, byteOffset?: number, encoding?: string): boolean;
    // (undocumented)
    indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;
    // (undocumented)
    keys(): IterableIterator<number>;
    // (undocumented)
    lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: string): number;
    // (undocumented)
    readDoubleBE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readDoubleLE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readFloatBE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readFloatLE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt16BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt16LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt32BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt32LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readInt8(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt16BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt16LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt32BE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt32LE(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUInt8(offset: number, noAssert?: boolean): number;
    // (undocumented)
    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    slice(start?: number, end?: number): this;
    // (undocumented)
    swap16(): this;
    // (undocumented)
    swap32(): this;
    // (undocumented)
    swap64(): this;
    // (undocumented)
    toJSON(): {
        type: 'Buffer';
        data: any[];
    };
    // (undocumented)
    toString(encoding?: string, start?: number, end?: number): string;
    // (undocumented)
    values(): IterableIterator<number>;
    // (undocumented)
    write(string: string, offset?: number, length?: number, encoding?: string): number;
    // (undocumented)
    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeInt8(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUInt8(value: number, offset: number, noAssert?: boolean): number;
    // (undocumented)
    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
    // (undocumented)
    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;
}

// @public
export interface INodeIncomingMessage {
    headers?: any;
    method?: any;
}

// @public
export interface INodeSocket {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    // (undocumented)
    addListener(event: "close", listener: () => void): this;
    // (undocumented)
    addListener(event: "data", listener: (chunk: any) => void): this;
    // (undocumented)
    addListener(event: "end", listener: () => void): this;
    // (undocumented)
    addListener(event: "readable", listener: () => void): this;
    // (undocumented)
    addListener(event: "error", listener: (err: Error) => void): this;
    // (undocumented)
    addListener(event: string | symbol, listener: (...args: any[]) => void): this;
    // Warning: (ae-forgotten-export) The symbol "AddressInfo" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    address(): AddressInfo | string;
    // (undocumented)
    readonly bufferSize: number;
    // (undocumented)
    readonly bytesRead: number;
    // (undocumented)
    readonly bytesWritten: number;
    // (undocumented)
    connect(options: any, connectionListener?: () => void): any;
    // (undocumented)
    connect(port: number, host: string, connectionListener?: () => void): any;
    // (undocumented)
    connect(port: number, connectionListener?: () => void): any;
    // (undocumented)
    connect(path: string, connectionListener?: () => void): any;
    // (undocumented)
    connecting: boolean;
    // (undocumented)
    cork(): void;
    // (undocumented)
    destroy(error?: Error): void;
    // (undocumented)
    _destroy(error: Error | null, callback: (error: Error | null) => void): void;
    // (undocumented)
    destroyed: boolean;
    // (undocumented)
    emit(event: "close"): boolean;
    // (undocumented)
    emit(event: "data", chunk: any): boolean;
    // (undocumented)
    emit(event: "end"): boolean;
    // (undocumented)
    emit(event: "readable"): boolean;
    // (undocumented)
    emit(event: "error", err: Error): boolean;
    // (undocumented)
    emit(event: string | symbol, ...args: any[]): boolean;
    // (undocumented)
    end(cb?: () => void): void;
    // (undocumented)
    end(chunk: any, cb?: () => void): void;
    // (undocumented)
    end(chunk: any, encoding?: string, cb?: () => void): void;
    // (undocumented)
    eventNames(): Array<string | symbol>;
    // (undocumented)
    _final(callback: (error?: Error | null) => void): void;
    // (undocumented)
    getMaxListeners(): number;
    // (undocumented)
    isPaused(): boolean;
    // (undocumented)
    listenerCount(type: string | symbol): number;
    // (undocumented)
    listeners(event: string | symbol): Function[];
    // (undocumented)
    readonly localAddress: string;
    // (undocumented)
    readonly localPort: number;
    // (undocumented)
    off(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: string, listener: (...args: any[]) => void): this;
    // (undocumented)
    on(event: "close", listener: (had_error: boolean) => void): this;
    // (undocumented)
    on(event: "connect", listener: () => void): this;
    // (undocumented)
    on(event: "data", listener: (data: INodeBuffer) => void): this;
    // (undocumented)
    on(event: "end", listener: () => void): this;
    // (undocumented)
    on(event: "error", listener: (err: Error) => void): this;
    // (undocumented)
    once(event: "close", listener: () => void): this;
    // (undocumented)
    once(event: "data", listener: (chunk: any) => void): this;
    // (undocumented)
    once(event: "end", listener: () => void): this;
    // (undocumented)
    once(event: "readable", listener: () => void): this;
    // (undocumented)
    once(event: "error", listener: (err: Error) => void): this;
    // (undocumented)
    once(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    pause(): this;
    // Warning: (ae-forgotten-export) The symbol "WritableStream" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    pipe<T extends WritableStream>(destination: T, options?: {
        end?: boolean;
    }): T;
    // (undocumented)
    prependListener(event: "close", listener: () => void): this;
    // (undocumented)
    prependListener(event: "data", listener: (chunk: any) => void): this;
    // (undocumented)
    prependListener(event: "end", listener: () => void): this;
    // (undocumented)
    prependListener(event: "readable", listener: () => void): this;
    // (undocumented)
    prependListener(event: "error", listener: (err: Error) => void): this;
    // (undocumented)
    prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    prependOnceListener(event: "close", listener: () => void): this;
    // (undocumented)
    prependOnceListener(event: "data", listener: (chunk: any) => void): this;
    // (undocumented)
    prependOnceListener(event: "end", listener: () => void): this;
    // (undocumented)
    prependOnceListener(event: "readable", listener: () => void): this;
    // (undocumented)
    prependOnceListener(event: "error", listener: (err: Error) => void): this;
    // (undocumented)
    prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    push(chunk: any, encoding?: string): boolean;
    // (undocumented)
    rawListeners(event: string | symbol): Function[];
    // (undocumented)
    read(size?: number): any;
    // (undocumented)
    _read(size: number): void;
    // (undocumented)
    readable: boolean;
    // (undocumented)
    readonly readableFlowing: boolean | null;
    // (undocumented)
    readonly readableHighWaterMark: number;
    // (undocumented)
    readonly readableLength: number;
    // (undocumented)
    ref(): any;
    // (undocumented)
    removeAllListeners(event?: string | symbol): this;
    // (undocumented)
    removeListener(event: string | symbol, listener: (...args: any[]) => void): this;
    // (undocumented)
    resume(): this;
    // (undocumented)
    setDefaultEncoding(encoding: string): this;
    // (undocumented)
    setEncoding(encoding: string): this;
    // (undocumented)
    setKeepAlive(enable?: boolean, initialDelay?: number): this;
    // (undocumented)
    setMaxListeners(n: number): this;
    // (undocumented)
    setNoDelay(noDelay?: boolean): this;
    // (undocumented)
    setTimeout(timeout: number, callback?: () => void): this;
    // (undocumented)
    uncork(): void;
    // (undocumented)
    unpipe(destination?: any): this;
    // (undocumented)
    unref(): any;
    // (undocumented)
    unshift(chunk: any): void;
    // (undocumented)
    wrap(oldStream: any): this;
    // (undocumented)
    writable: boolean;
    // (undocumented)
    readonly writableHighWaterMark: number;
    // (undocumented)
    readonly writableLength: number;
    // Warning: (ae-forgotten-export) The symbol "ValidBuffer" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    write(buffer: ValidBuffer, cb?: (err?: Error) => void): boolean;
    // (undocumented)
    write(str: string, encoding?: string, cb?: Function): boolean;
    // (undocumented)
    write(buffer: ValidBuffer): boolean;
    // (undocumented)
    write(str: string, cb?: Function): boolean;
    // (undocumented)
    write(str: string, encoding?: string, fd?: string): boolean;
    // (undocumented)
    write(data: any, encoding?: string, callback?: Function): void;
    // (undocumented)
    write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;
    // (undocumented)
    write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;
    // (undocumented)
    _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;
    // (undocumented)
    _writev?(chunks: Array<{
        chunk: any;
        encoding: string;
    }>, callback: (error?: Error | null) => void): void;
}

// @public
export interface IReceiveRequest {
    // (undocumented)
    path?: string;
    // (undocumented)
    streams: ContentStream[];
    // (undocumented)
    verb?: string;
}

// @public
export interface IReceiveResponse {
    // (undocumented)
    statusCode?: number;
    // (undocumented)
    streams: ContentStream[];
}

// @public (undocumented)
export interface ISocket {
    // (undocumented)
    close(): any;
    // (undocumented)
    connect(serverAddress: string): Promise<void>;
    // (undocumented)
    isConnected: boolean;
    // (undocumented)
    setOnCloseHandler(handler: (x: any) => void): any;
    // (undocumented)
    setOnErrorHandler(handler: (x: any) => void): any;
    // (undocumented)
    setOnMessageHandler(handler: (x: any) => void): any;
    // (undocumented)
    write(buffer: INodeBuffer): any;
}

// @public
export interface IStreamingTransportClient {
    // (undocumented)
    connect(): Promise<void>;
    // (undocumented)
    disconnect(): void;
    // (undocumented)
    send(request: StreamingRequest): Promise<IReceiveResponse>;
}

// @public
export interface IStreamingTransportServer {
    // (undocumented)
    disconnect(): void;
    // (undocumented)
    isConnected?: boolean;
    // (undocumented)
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    // (undocumented)
    start(): Promise<string>;
}

// @public
export class NamedPipeClient implements IStreamingTransportClient {
    constructor(baseName: string, requestHandler?: RequestHandler, autoReconnect?: boolean);
    connect(): Promise<void>;
    disconnect(): void;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    }

// @public
export class NamedPipeServer implements IStreamingTransportServer {
    constructor(baseName: string, requestHandler?: RequestHandler, autoReconnect?: boolean);
    disconnect(): void;
    readonly isConnected: boolean;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    start(): Promise<string>;
}

// @public (undocumented)
export class NodeWebSocket implements ISocket {
    constructor(wsSocket?: WebSocket);
    close(code?: number, data?: string): void;
    connect(serverAddress: any, port?: number): Promise<void>;
    create(req: INodeIncomingMessage, socket: INodeSocket, head: INodeBuffer): Promise<void>;
    readonly isConnected: boolean;
    setOnCloseHandler(handler: (x: any) => void): void;
    setOnErrorHandler(handler: (x: any) => void): void;
    setOnMessageHandler(handler: (x: any) => void): void;
    write(buffer: INodeBuffer): void;
    // (undocumented)
    protected wsServer: WebSocket.Server;
    }

// @public (undocumented)
export class NodeWebSocketFactory extends NodeWebSocketFactoryBase {
    constructor();
    createWebSocket(req: INodeIncomingMessage, socket: INodeSocket, head: INodeBuffer): Promise<NodeWebSocket>;
}

// @public (undocumented)
export abstract class NodeWebSocketFactoryBase {
    // (undocumented)
    abstract createWebSocket(req: INodeIncomingMessage, socket: INodeSocket, head: INodeBuffer): Promise<ISocket>;
}

// @public
export abstract class RequestHandler {
    abstract processRequest(request: IReceiveRequest): Promise<StreamingResponse>;
}

// @public (undocumented)
export class StreamingRequest {
    addStream(content: HttpContent): void;
    static create(method: string, path?: string, body?: HttpContent): StreamingRequest;
    path: string;
    setBody(body: any): void;
    // Warning: (ae-forgotten-export) The symbol "HttpContentStream" needs to be exported by the entry point index.d.ts
    streams: HttpContentStream[];
    verb: string;
}

// @public (undocumented)
export class StreamingResponse {
    addStream(content: HttpContent): void;
    static create(statusCode: number, body?: HttpContent): StreamingResponse;
    setBody(body: any): void;
    // (undocumented)
    statusCode: number;
    // (undocumented)
    streams: HttpContentStream[];
}

// @public (undocumented)
export interface SubscribableStream {
    // (undocumented)
    end?(cb?: () => void): void;
    // (undocumented)
    end?(chunk: any, cb?: () => void): void;
    // (undocumented)
    end?(chunk: any, encoding?: string, cb?: () => void): void;
    // (undocumented)
    push?(chunk: any): boolean;
    // (undocumented)
    push?(chunk: any, encoding: string): boolean;
    // (undocumented)
    push?(chunk: any, encoding?: string): boolean;
    // (undocumented)
    read(size?: number): any;
    // (undocumented)
    write?(chunk: any): boolean;
    // (undocumented)
    write?(chunk: any, encoding: string): boolean;
    // (undocumented)
    write?(chunk: any, encoding: string, callback: (error?: Error | null) => void): boolean;
}

// @public (undocumented)
export class SubscribableStream extends Duplex implements SubscribableStream {
    constructor(options?: DuplexOptions);
    // (undocumented)
    length: number;
    // (undocumented)
    _read(size: number): void;
    // (undocumented)
    subscribe(onData: (chunk: any) => void): void;
    // (undocumented)
    _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;
}

// @public
export class WebSocketClient implements IStreamingTransportClient {
    constructor({ url, requestHandler, disconnectionHandler }: {
        url: any;
        requestHandler: any;
        disconnectionHandler?: any;
    });
    connect(): Promise<void>;
    disconnect(): void;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    }

// @public
export class WebSocketServer implements IStreamingTransportServer {
    constructor(socket: ISocket, requestHandler?: RequestHandler);
    disconnect(): void;
    readonly isConnected: boolean;
    send(request: StreamingRequest): Promise<IReceiveResponse>;
    start(): Promise<string>;
    }


// (No @packageDocumentation comment for this package)

```
