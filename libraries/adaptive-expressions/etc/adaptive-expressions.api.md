## API Report File for "adaptive-expressions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ANTLRErrorListener } from 'antlr4ts';
import { ATN } from 'antlr4ts/atn/ATN';
import { CharStream } from 'antlr4ts/CharStream';
import { Lexer } from 'antlr4ts/Lexer';
import { Parser } from 'antlr4ts/Parser';
import { ParserRuleContext } from 'antlr4ts/ParserRuleContext';
import { ParseTree } from 'antlr4ts/tree';
import { ParseTreeListener } from 'antlr4ts/tree/ParseTreeListener';
import { ParseTreeVisitor } from 'antlr4ts/tree/ParseTreeVisitor';
import { RecognitionException } from 'antlr4ts';
import { Recognizer } from 'antlr4ts';
import { RuleContext } from 'antlr4ts/RuleContext';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { TokenStream } from 'antlr4ts/TokenStream';
import { Vocabulary } from 'antlr4ts/Vocabulary';

// @public (undocumented)
export class Alpha_numsContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    digit(): DigitContext[];
    // (undocumented)
    digit(i: number): DigitContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    letter(): LetterContext[];
    // (undocumented)
    letter(i: number): LetterContext;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    Underscore(): TerminalNode[];
    // (undocumented)
    Underscore(i: number): TerminalNode;
}

// @public (undocumented)
export class AlternationContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    expr(): ExprContext[];
    // (undocumented)
    expr(i: number): ExprContext;
    // (undocumented)
    Pipe(): TerminalNode[];
    // (undocumented)
    Pipe(i: number): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class ArgsListContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    COMMA(): TerminalNode[];
    // (undocumented)
    COMMA(i: number): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext[];
    // (undocumented)
    expression(i: number): ExpressionContext;
    // (undocumented)
    lambda(): LambdaContext[];
    // (undocumented)
    lambda(i: number): LambdaContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class ArrayCreationExpContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    argsList(): ArgsListContext | undefined;
    // (undocumented)
    CLOSE_SQUARE_BRACKET(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    OPEN_SQUARE_BRACKET(): TerminalNode;
}

// @public
export class ArrayExpression<T> extends ExpressionProperty<T[]> {
    constructor(value?: T[] | string | Expression);
    setValue(value: T[] | string | Expression): void;
}

// @public
export class ArrayExpressionConverter<T> {
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input<T> | ArrayExpression<T>): ArrayExpression<T>;
}

// @public (undocumented)
export class AtomContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    capture(): CaptureContext | undefined;
    // (undocumented)
    Caret(): TerminalNode | undefined;
    // (undocumented)
    character_class(): Character_classContext | undefined;
    // (undocumented)
    Dot(): TerminalNode | undefined;
    // (undocumented)
    EndOfSubject(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    literal(): LiteralContext | undefined;
    // (undocumented)
    non_capture(): Non_captureContext | undefined;
    // (undocumented)
    option(): OptionContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    shared_atom(): Shared_atomContext | undefined;
}

// @public (undocumented)
export class BinaryOpExpContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    ASTERISK(): TerminalNode | undefined;
    // (undocumented)
    DOUBLE_AND(): TerminalNode | undefined;
    // (undocumented)
    DOUBLE_EQUAL(): TerminalNode | undefined;
    // (undocumented)
    DOUBLE_VERTICAL_CYLINDER(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext[];
    // (undocumented)
    expression(i: number): ExpressionContext;
    // (undocumented)
    LESS_OR_EQUAl(): TerminalNode | undefined;
    // (undocumented)
    LESS_THAN(): TerminalNode | undefined;
    // (undocumented)
    MORE_OR_EQUAL(): TerminalNode | undefined;
    // (undocumented)
    MORE_THAN(): TerminalNode | undefined;
    // (undocumented)
    NOT_EQUAL(): TerminalNode | undefined;
    // (undocumented)
    NULL_COALESCE(): TerminalNode | undefined;
    // (undocumented)
    PERCENT(): TerminalNode | undefined;
    // (undocumented)
    PLUS(): TerminalNode | undefined;
    // (undocumented)
    SINGLE_AND(): TerminalNode | undefined;
    // (undocumented)
    SLASH(): TerminalNode | undefined;
    // (undocumented)
    SUBSTRACT(): TerminalNode | undefined;
    // (undocumented)
    XOR(): TerminalNode | undefined;
}

// @public
export class BoolExpression extends ExpressionProperty<boolean> {
    constructor(value?: boolean | string | Expression);
    setValue(value: boolean | string | Expression): void;
}

// @public
export class BoolExpressionConverter {
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input_2 | BoolExpression): BoolExpression;
}

// @public (undocumented)
export class CaptureContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    alternation(): AlternationContext;
    // (undocumented)
    CloseParen(): TerminalNode;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    GreaterThan(): TerminalNode | undefined;
    // (undocumented)
    LessThan(): TerminalNode | undefined;
    // (undocumented)
    name(): NameContext | undefined;
    // (undocumented)
    OpenParen(): TerminalNode;
    // (undocumented)
    QuestionMark(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class Cc_atomContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    cc_literal(): Cc_literalContext[];
    // (undocumented)
    cc_literal(i: number): Cc_literalContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    Hyphen(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    shared_atom(): Shared_atomContext | undefined;
}

// @public (undocumented)
export class Cc_literalContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    Caret(): TerminalNode | undefined;
    // (undocumented)
    CharacterClassStart(): TerminalNode | undefined;
    // (undocumented)
    CloseParen(): TerminalNode | undefined;
    // (undocumented)
    Dot(): TerminalNode | undefined;
    // (undocumented)
    EndOfSubject(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    OpenParen(): TerminalNode | undefined;
    // (undocumented)
    Pipe(): TerminalNode | undefined;
    // (undocumented)
    Plus(): TerminalNode | undefined;
    // (undocumented)
    QuestionMark(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    shared_literal(): Shared_literalContext | undefined;
    // (undocumented)
    Star(): TerminalNode | undefined;
}

// @public (undocumented)
export class Character_classContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    Caret(): TerminalNode | undefined;
    // (undocumented)
    cc_atom(): Cc_atomContext[];
    // (undocumented)
    cc_atom(i: number): Cc_atomContext;
    // (undocumented)
    CharacterClassEnd(): TerminalNode;
    // (undocumented)
    CharacterClassStart(): TerminalNode;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class Clause extends Expression {
    constructor(clauseOrExpression?: Clause | Expression | Expression[]);
    anyBindings: Map<string, string>;
    matches(clause: Clause, memory: MemoryInterface | any): boolean;
    relationship(other: Clause, comparers: PredicateComparers): RelationshipType;
    splitIgnores(): void;
    subsumed: boolean;
    toString(builder?: string[], indent?: number): string;
}

// @public
export class CommonRegex {
    static CreateRegex(pattern: string): RegExp;
    }

// @public (undocumented)
export class CommonRegexLexer extends Lexer {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: CharStream);
    // (undocumented)
    static readonly ALC = 44;
    // (undocumented)
    static readonly Ampersand = 43;
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    static readonly AUC = 70;
    // (undocumented)
    static readonly Backslash = 10;
    // (undocumented)
    static readonly BellChar = 3;
    // (undocumented)
    static readonly BLC = 45;
    // (undocumented)
    static readonly BlockQuoted = 2;
    // (undocumented)
    static readonly BUC = 71;
    // (undocumented)
    static readonly Caret = 23;
    // (undocumented)
    static readonly CarriageReturn = 8;
    // (undocumented)
    static readonly channelNames: string[];
    // (undocumented)
    readonly channelNames: string[];
    // (undocumented)
    static readonly CharacterClassEnd = 22;
    // (undocumented)
    static readonly CharacterClassStart = 21;
    // (undocumented)
    static readonly CharWithoutProperty = 16;
    // (undocumented)
    static readonly CharWithProperty = 15;
    // (undocumented)
    static readonly CLC = 46;
    // (undocumented)
    static readonly CloseBrace = 29;
    // (undocumented)
    static readonly CloseParen = 34;
    // (undocumented)
    static readonly Colon = 39;
    // (undocumented)
    static readonly Comma = 30;
    // (undocumented)
    static readonly ControlChar = 4;
    // (undocumented)
    static readonly CUC = 72;
    // (undocumented)
    static readonly D0 = 105;
    // (undocumented)
    static readonly D1 = 96;
    // (undocumented)
    static readonly D2 = 97;
    // (undocumented)
    static readonly D3 = 98;
    // (undocumented)
    static readonly D4 = 99;
    // (undocumented)
    static readonly D5 = 100;
    // (undocumented)
    static readonly D6 = 101;
    // (undocumented)
    static readonly D7 = 102;
    // (undocumented)
    static readonly D8 = 103;
    // (undocumented)
    static readonly D9 = 104;
    // (undocumented)
    static readonly DecimalDigit = 13;
    // (undocumented)
    static readonly DLC = 47;
    // (undocumented)
    static readonly Dot = 12;
    // (undocumented)
    static readonly DUC = 73;
    // (undocumented)
    static readonly ELC = 48;
    // (undocumented)
    static readonly EndOfSubject = 31;
    // (undocumented)
    static readonly Equals = 41;
    // (undocumented)
    static readonly EscapeChar = 5;
    // (undocumented)
    static readonly EUC = 74;
    // (undocumented)
    static readonly Exclamation = 42;
    // (undocumented)
    static readonly FLC = 49;
    // (undocumented)
    static readonly FormFeed = 6;
    // (undocumented)
    static readonly FUC = 75;
    // (undocumented)
    static readonly GLC = 50;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly GreaterThan = 36;
    // (undocumented)
    static readonly GUC = 76;
    // (undocumented)
    static readonly Hash = 40;
    // (undocumented)
    static readonly HexChar = 11;
    // (undocumented)
    static readonly HLC = 51;
    // (undocumented)
    static readonly HUC = 77;
    // (undocumented)
    static readonly Hyphen = 24;
    // (undocumented)
    static readonly ILC = 52;
    // (undocumented)
    static readonly IUC = 78;
    // (undocumented)
    static readonly JLC = 53;
    // (undocumented)
    static readonly JUC = 79;
    // (undocumented)
    static readonly KLC = 54;
    // (undocumented)
    static readonly KUC = 80;
    // (undocumented)
    static readonly LessThan = 35;
    // (undocumented)
    static readonly LLC = 55;
    // (undocumented)
    static readonly LUC = 81;
    // (undocumented)
    static readonly MLC = 56;
    // (undocumented)
    static readonly modeNames: string[];
    // (undocumented)
    readonly modeNames: string[];
    // (undocumented)
    static readonly MUC = 82;
    // (undocumented)
    static readonly NewLine = 7;
    // (undocumented)
    static readonly NLC = 57;
    // (undocumented)
    static readonly NotDecimalDigit = 14;
    // (undocumented)
    static readonly NotWhiteSpace = 18;
    // (undocumented)
    static readonly NotWordChar = 20;
    // (undocumented)
    static readonly NUC = 83;
    // (undocumented)
    static readonly OLC = 58;
    // (undocumented)
    static readonly OpenBrace = 28;
    // (undocumented)
    static readonly OpenParen = 33;
    // (undocumented)
    static readonly OtherChar = 106;
    // (undocumented)
    static readonly OUC = 84;
    // (undocumented)
    static readonly Pipe = 32;
    // (undocumented)
    static readonly PLC = 59;
    // (undocumented)
    static readonly Plus = 26;
    // (undocumented)
    static readonly PUC = 85;
    // (undocumented)
    static readonly QLC = 60;
    // (undocumented)
    static readonly QUC = 86;
    // (undocumented)
    static readonly QuestionMark = 25;
    // (undocumented)
    static readonly Quoted = 1;
    // (undocumented)
    static readonly RLC = 61;
    // (undocumented)
    static readonly RUC = 87;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    static readonly SingleQuote = 37;
    // (undocumented)
    static readonly SLC = 62;
    // (undocumented)
    static readonly Star = 27;
    // (undocumented)
    static readonly SUC = 88;
    // (undocumented)
    static readonly Tab = 9;
    // (undocumented)
    static readonly TLC = 63;
    // (undocumented)
    static readonly TUC = 89;
    // (undocumented)
    static readonly ULC = 64;
    // (undocumented)
    static readonly Underscore = 38;
    // (undocumented)
    static readonly UUC = 90;
    // (undocumented)
    static readonly VLC = 65;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
    // (undocumented)
    static readonly VUC = 91;
    // (undocumented)
    static readonly WhiteSpace = 17;
    // (undocumented)
    static readonly WLC = 66;
    // (undocumented)
    static readonly WordChar = 19;
    // (undocumented)
    static readonly WUC = 92;
    // (undocumented)
    static readonly XLC = 67;
    // (undocumented)
    static readonly XUC = 93;
    // (undocumented)
    static readonly YLC = 68;
    // (undocumented)
    static readonly YUC = 94;
    // (undocumented)
    static readonly ZLC = 69;
    // (undocumented)
    static readonly ZUC = 95;
}

// @public
export interface CommonRegexListener extends ParseTreeListener {
    enterAlpha_nums?: (ctx: Alpha_numsContext) => void;
    enterAlternation?: (ctx: AlternationContext) => void;
    enterAtom?: (ctx: AtomContext) => void;
    enterCapture?: (ctx: CaptureContext) => void;
    enterCc_atom?: (ctx: Cc_atomContext) => void;
    enterCc_literal?: (ctx: Cc_literalContext) => void;
    enterCharacter_class?: (ctx: Character_classContext) => void;
    enterDigit?: (ctx: DigitContext) => void;
    enterDigits?: (ctx: DigitsContext) => void;
    enterElement?: (ctx: ElementContext) => void;
    enterExpr?: (ctx: ExprContext) => void;
    enterLetter?: (ctx: LetterContext) => void;
    enterLiteral?: (ctx: LiteralContext) => void;
    enterName?: (ctx: NameContext) => void;
    enterNon_capture?: (ctx: Non_captureContext) => void;
    enterNon_close_paren?: (ctx: Non_close_parenContext) => void;
    enterNon_close_parens?: (ctx: Non_close_parensContext) => void;
    enterNumber?: (ctx: NumberContext) => void;
    enterOctal_char?: (ctx: Octal_charContext) => void;
    enterOctal_digit?: (ctx: Octal_digitContext) => void;
    enterOption?: (ctx: OptionContext) => void;
    enterOption_flag?: (ctx: Option_flagContext) => void;
    enterParse?: (ctx: ParseContext) => void;
    enterQuantifier?: (ctx: QuantifierContext) => void;
    enterQuantifier_type?: (ctx: Quantifier_typeContext) => void;
    enterShared_atom?: (ctx: Shared_atomContext) => void;
    enterShared_literal?: (ctx: Shared_literalContext) => void;
    exitAlpha_nums?: (ctx: Alpha_numsContext) => void;
    exitAlternation?: (ctx: AlternationContext) => void;
    exitAtom?: (ctx: AtomContext) => void;
    exitCapture?: (ctx: CaptureContext) => void;
    exitCc_atom?: (ctx: Cc_atomContext) => void;
    exitCc_literal?: (ctx: Cc_literalContext) => void;
    exitCharacter_class?: (ctx: Character_classContext) => void;
    exitDigit?: (ctx: DigitContext) => void;
    exitDigits?: (ctx: DigitsContext) => void;
    exitElement?: (ctx: ElementContext) => void;
    exitExpr?: (ctx: ExprContext) => void;
    exitLetter?: (ctx: LetterContext) => void;
    exitLiteral?: (ctx: LiteralContext) => void;
    exitName?: (ctx: NameContext) => void;
    exitNon_capture?: (ctx: Non_captureContext) => void;
    exitNon_close_paren?: (ctx: Non_close_parenContext) => void;
    exitNon_close_parens?: (ctx: Non_close_parensContext) => void;
    exitNumber?: (ctx: NumberContext) => void;
    exitOctal_char?: (ctx: Octal_charContext) => void;
    exitOctal_digit?: (ctx: Octal_digitContext) => void;
    exitOption?: (ctx: OptionContext) => void;
    exitOption_flag?: (ctx: Option_flagContext) => void;
    exitParse?: (ctx: ParseContext) => void;
    exitQuantifier?: (ctx: QuantifierContext) => void;
    exitQuantifier_type?: (ctx: Quantifier_typeContext) => void;
    exitShared_atom?: (ctx: Shared_atomContext) => void;
    exitShared_literal?: (ctx: Shared_literalContext) => void;
}

// @public (undocumented)
export class CommonRegexParser extends Parser {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: TokenStream);
    // (undocumented)
    static readonly ALC = 44;
    // (undocumented)
    alpha_nums(): Alpha_numsContext;
    // (undocumented)
    alternation(): AlternationContext;
    // (undocumented)
    static readonly Ampersand = 43;
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    atom(): AtomContext;
    // (undocumented)
    static readonly AUC = 70;
    // (undocumented)
    static readonly Backslash = 10;
    // (undocumented)
    static readonly BellChar = 3;
    // (undocumented)
    static readonly BLC = 45;
    // (undocumented)
    static readonly BlockQuoted = 2;
    // (undocumented)
    static readonly BUC = 71;
    // (undocumented)
    capture(): CaptureContext;
    // (undocumented)
    static readonly Caret = 23;
    // (undocumented)
    static readonly CarriageReturn = 8;
    // (undocumented)
    cc_atom(): Cc_atomContext;
    // (undocumented)
    cc_literal(): Cc_literalContext;
    // (undocumented)
    character_class(): Character_classContext;
    // (undocumented)
    static readonly CharacterClassEnd = 22;
    // (undocumented)
    static readonly CharacterClassStart = 21;
    // (undocumented)
    static readonly CharWithoutProperty = 16;
    // (undocumented)
    static readonly CharWithProperty = 15;
    // (undocumented)
    static readonly CLC = 46;
    // (undocumented)
    static readonly CloseBrace = 29;
    // (undocumented)
    static readonly CloseParen = 34;
    // (undocumented)
    static readonly Colon = 39;
    // (undocumented)
    static readonly Comma = 30;
    // (undocumented)
    static readonly ControlChar = 4;
    // (undocumented)
    static readonly CUC = 72;
    // (undocumented)
    static readonly D0 = 105;
    // (undocumented)
    static readonly D1 = 96;
    // (undocumented)
    static readonly D2 = 97;
    // (undocumented)
    static readonly D3 = 98;
    // (undocumented)
    static readonly D4 = 99;
    // (undocumented)
    static readonly D5 = 100;
    // (undocumented)
    static readonly D6 = 101;
    // (undocumented)
    static readonly D7 = 102;
    // (undocumented)
    static readonly D8 = 103;
    // (undocumented)
    static readonly D9 = 104;
    // (undocumented)
    static readonly DecimalDigit = 13;
    // (undocumented)
    digit(): DigitContext;
    // (undocumented)
    digits(): DigitsContext;
    // (undocumented)
    static readonly DLC = 47;
    // (undocumented)
    static readonly Dot = 12;
    // (undocumented)
    static readonly DUC = 73;
    // (undocumented)
    static readonly ELC = 48;
    // (undocumented)
    element(): ElementContext;
    // (undocumented)
    static readonly EndOfSubject = 31;
    // (undocumented)
    static readonly Equals = 41;
    // (undocumented)
    static readonly EscapeChar = 5;
    // (undocumented)
    static readonly EUC = 74;
    // (undocumented)
    static readonly Exclamation = 42;
    // (undocumented)
    expr(): ExprContext;
    // (undocumented)
    static readonly FLC = 49;
    // (undocumented)
    static readonly FormFeed = 6;
    // (undocumented)
    static readonly FUC = 75;
    // (undocumented)
    static readonly GLC = 50;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly GreaterThan = 36;
    // (undocumented)
    static readonly GUC = 76;
    // (undocumented)
    static readonly Hash = 40;
    // (undocumented)
    static readonly HexChar = 11;
    // (undocumented)
    static readonly HLC = 51;
    // (undocumented)
    static readonly HUC = 77;
    // (undocumented)
    static readonly Hyphen = 24;
    // (undocumented)
    static readonly ILC = 52;
    // (undocumented)
    static readonly IUC = 78;
    // (undocumented)
    static readonly JLC = 53;
    // (undocumented)
    static readonly JUC = 79;
    // (undocumented)
    static readonly KLC = 54;
    // (undocumented)
    static readonly KUC = 80;
    // (undocumented)
    static readonly LessThan = 35;
    // (undocumented)
    letter(): LetterContext;
    // (undocumented)
    literal(): LiteralContext;
    // (undocumented)
    static readonly LLC = 55;
    // (undocumented)
    static readonly LUC = 81;
    // (undocumented)
    static readonly MLC = 56;
    // (undocumented)
    static readonly MUC = 82;
    // (undocumented)
    name(): NameContext;
    // (undocumented)
    static readonly NewLine = 7;
    // (undocumented)
    static readonly NLC = 57;
    // (undocumented)
    non_capture(): Non_captureContext;
    // (undocumented)
    non_close_paren(): Non_close_parenContext;
    // (undocumented)
    non_close_parens(): Non_close_parensContext;
    // (undocumented)
    static readonly NotDecimalDigit = 14;
    // (undocumented)
    static readonly NotWhiteSpace = 18;
    // (undocumented)
    static readonly NotWordChar = 20;
    // (undocumented)
    static readonly NUC = 83;
    // (undocumented)
    number(): NumberContext;
    // (undocumented)
    octal_char(): Octal_charContext;
    // (undocumented)
    octal_digit(): Octal_digitContext;
    // (undocumented)
    static readonly OLC = 58;
    // (undocumented)
    static readonly OpenBrace = 28;
    // (undocumented)
    static readonly OpenParen = 33;
    // (undocumented)
    option(): OptionContext;
    // (undocumented)
    option_flag(): Option_flagContext;
    // (undocumented)
    static readonly OtherChar = 106;
    // (undocumented)
    static readonly OUC = 84;
    // (undocumented)
    parse(): ParseContext;
    // (undocumented)
    static readonly Pipe = 32;
    // (undocumented)
    static readonly PLC = 59;
    // (undocumented)
    static readonly Plus = 26;
    // (undocumented)
    static readonly PUC = 85;
    // (undocumented)
    static readonly QLC = 60;
    // (undocumented)
    quantifier(): QuantifierContext;
    // (undocumented)
    quantifier_type(): Quantifier_typeContext;
    // (undocumented)
    static readonly QUC = 86;
    // (undocumented)
    static readonly QuestionMark = 25;
    // (undocumented)
    static readonly Quoted = 1;
    // (undocumented)
    static readonly RLC = 61;
    // (undocumented)
    static readonly RUC = 87;
    // (undocumented)
    static readonly RULE_alpha_nums = 23;
    // (undocumented)
    static readonly RULE_alternation = 1;
    // (undocumented)
    static readonly RULE_atom = 11;
    // (undocumented)
    static readonly RULE_capture = 7;
    // (undocumented)
    static readonly RULE_cc_atom = 12;
    // (undocumented)
    static readonly RULE_cc_literal = 15;
    // (undocumented)
    static readonly RULE_character_class = 6;
    // (undocumented)
    static readonly RULE_digit = 21;
    // (undocumented)
    static readonly RULE_digits = 20;
    // (undocumented)
    static readonly RULE_element = 3;
    // (undocumented)
    static readonly RULE_expr = 2;
    // (undocumented)
    static readonly RULE_letter = 26;
    // (undocumented)
    static readonly RULE_literal = 14;
    // (undocumented)
    static readonly RULE_name = 22;
    // (undocumented)
    static readonly RULE_non_capture = 8;
    // (undocumented)
    static readonly RULE_non_close_paren = 25;
    // (undocumented)
    static readonly RULE_non_close_parens = 24;
    // (undocumented)
    static readonly RULE_number = 17;
    // (undocumented)
    static readonly RULE_octal_char = 18;
    // (undocumented)
    static readonly RULE_octal_digit = 19;
    // (undocumented)
    static readonly RULE_option = 9;
    // (undocumented)
    static readonly RULE_option_flag = 10;
    // (undocumented)
    static readonly RULE_parse = 0;
    // (undocumented)
    static readonly RULE_quantifier = 4;
    // (undocumented)
    static readonly RULE_quantifier_type = 5;
    // (undocumented)
    static readonly RULE_shared_atom = 13;
    // (undocumented)
    static readonly RULE_shared_literal = 16;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    shared_atom(): Shared_atomContext;
    // (undocumented)
    shared_literal(): Shared_literalContext;
    // (undocumented)
    static readonly SingleQuote = 37;
    // (undocumented)
    static readonly SLC = 62;
    // (undocumented)
    static readonly Star = 27;
    // (undocumented)
    static readonly SUC = 88;
    // (undocumented)
    static readonly Tab = 9;
    // (undocumented)
    static readonly TLC = 63;
    // (undocumented)
    static readonly TUC = 89;
    // (undocumented)
    static readonly ULC = 64;
    // (undocumented)
    static readonly Underscore = 38;
    // (undocumented)
    static readonly UUC = 90;
    // (undocumented)
    static readonly VLC = 65;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
    // (undocumented)
    static readonly VUC = 91;
    // (undocumented)
    static readonly WhiteSpace = 17;
    // (undocumented)
    static readonly WLC = 66;
    // (undocumented)
    static readonly WordChar = 19;
    // (undocumented)
    static readonly WUC = 92;
    // (undocumented)
    static readonly XLC = 67;
    // (undocumented)
    static readonly XUC = 93;
    // (undocumented)
    static readonly YLC = 68;
    // (undocumented)
    static readonly YUC = 94;
    // (undocumented)
    static readonly ZLC = 69;
    // (undocumented)
    static readonly ZUC = 95;
}

// @public
export interface CommonRegexVisitor<Result> extends ParseTreeVisitor<Result> {
    visitAlpha_nums?: (ctx: Alpha_numsContext) => Result;
    visitAlternation?: (ctx: AlternationContext) => Result;
    visitAtom?: (ctx: AtomContext) => Result;
    visitCapture?: (ctx: CaptureContext) => Result;
    visitCc_atom?: (ctx: Cc_atomContext) => Result;
    visitCc_literal?: (ctx: Cc_literalContext) => Result;
    visitCharacter_class?: (ctx: Character_classContext) => Result;
    visitDigit?: (ctx: DigitContext) => Result;
    visitDigits?: (ctx: DigitsContext) => Result;
    visitElement?: (ctx: ElementContext) => Result;
    visitExpr?: (ctx: ExprContext) => Result;
    visitLetter?: (ctx: LetterContext) => Result;
    visitLiteral?: (ctx: LiteralContext) => Result;
    visitName?: (ctx: NameContext) => Result;
    visitNon_capture?: (ctx: Non_captureContext) => Result;
    visitNon_close_paren?: (ctx: Non_close_parenContext) => Result;
    visitNon_close_parens?: (ctx: Non_close_parensContext) => Result;
    visitNumber?: (ctx: NumberContext) => Result;
    visitOctal_char?: (ctx: Octal_charContext) => Result;
    visitOctal_digit?: (ctx: Octal_digitContext) => Result;
    visitOption?: (ctx: OptionContext) => Result;
    visitOption_flag?: (ctx: Option_flagContext) => Result;
    visitParse?: (ctx: ParseContext) => Result;
    visitQuantifier?: (ctx: QuantifierContext) => Result;
    visitQuantifier_type?: (ctx: Quantifier_typeContext) => Result;
    visitShared_atom?: (ctx: Shared_atomContext) => Result;
    visitShared_literal?: (ctx: Shared_literalContext) => Result;
}

// @public
export class ComparisonEvaluator extends ExpressionEvaluator {
    constructor(type: string, func: (arg0: any[]) => boolean, validator: ValidateExpressionDelegate, verify?: VerifyExpression);
    }

// @public
export class Constant extends Expression {
    constructor(value: any);
    deepEquals(other: Expression): boolean;
    toString(): string;
    value: any;
    }

// @public
export function convertCSharpDateTimeToDayjs(fmtString: string): string;

// @public (undocumented)
export class DigitContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    D0(): TerminalNode | undefined;
    // (undocumented)
    D1(): TerminalNode | undefined;
    // (undocumented)
    D2(): TerminalNode | undefined;
    // (undocumented)
    D3(): TerminalNode | undefined;
    // (undocumented)
    D4(): TerminalNode | undefined;
    // (undocumented)
    D5(): TerminalNode | undefined;
    // (undocumented)
    D6(): TerminalNode | undefined;
    // (undocumented)
    D7(): TerminalNode | undefined;
    // (undocumented)
    D8(): TerminalNode | undefined;
    // (undocumented)
    D9(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class DigitsContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    digit(): DigitContext[];
    // (undocumented)
    digit(i: number): DigitContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class ElementContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    atom(): AtomContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    quantifier(): QuantifierContext | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class EnumExpression<T> extends ExpressionProperty<T> {
    constructor(value: T | string | Expression);
    setValue(value: T | string | Expression): void;
}

// @public
export class EnumExpressionConverter<T> {
    constructor(enumValue: unknown);
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input_3<T> | EnumExpression<T>): EnumExpression<T>;
    }

// @public
export type EvaluateExpressionDelegate = (expression: Expression, state: MemoryInterface, options: Options) => ValueWithError;

// @public
export type EvaluatorLookup = (type: string) => ExpressionEvaluator;

// @public (undocumented)
export class ExprContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    element(): ElementContext[];
    // (undocumented)
    element(i: number): ElementContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class Expression {
    constructor(type: string, evaluator: ExpressionEvaluator, ...children: Expression[]);
    static andExpression(...children: Expression[]): Expression;
    children: Expression[];
    deepEquals(other: Expression): boolean;
    static equalsExpression(...children: Expression[]): Expression;
    readonly evaluator: ExpressionEvaluator;
    static readonly functions: FunctionTable;
    static lambaExpression(func: EvaluateExpressionDelegate): Expression;
    static lambda(func: (arg0: any) => any): Expression;
    static lookup(functionName: string): ExpressionEvaluator;
    static makeExpression(type: string, evaluator: ExpressionEvaluator, ...children: Expression[]): Expression;
    static notExpression(child: Expression): Expression;
    static orExpression(...children: Expression[]): Expression;
    static parse(expression: string, lookup?: EvaluatorLookup): Expression;
    references(): string[];
    referenceWalk(expression: Expression, extension?: (arg0: Expression) => boolean): {
        path: string;
        refs: Set<string>;
    };
    readonly returnType: ReturnType_2;
    static setPathToValue(property: Expression, value: any): Expression;
    toString(): string;
    tryEvaluate(state: MemoryInterface | any, options?: Options): ValueWithError;
    readonly type: string;
    validate: () => void;
    validateTree(): void;
}

// @public (undocumented)
export class ExpressionAntlrLexer extends Lexer {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: CharStream);
    // (undocumented)
    action(_localctx: RuleContext, ruleIndex: number, actionIndex: number): void;
    // (undocumented)
    static readonly ARROW = 27;
    // (undocumented)
    static readonly ASTERISK = 6;
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    static readonly channelNames: string[];
    // (undocumented)
    readonly channelNames: string[];
    // (undocumented)
    static readonly CLOSE_BRACKET = 19;
    // (undocumented)
    static readonly CLOSE_CURLY_BRACKET = 24;
    // (undocumented)
    static readonly CLOSE_SQUARE_BRACKET = 22;
    // (undocumented)
    static readonly COLON = 26;
    // (undocumented)
    static readonly COMMA = 25;
    // (undocumented)
    static readonly DOT = 20;
    // (undocumented)
    static readonly DOUBLE_AND = 12;
    // (undocumented)
    static readonly DOUBLE_EQUAL = 9;
    // (undocumented)
    static readonly DOUBLE_VERTICAL_CYLINDER = 13;
    // (undocumented)
    static readonly ESCAPE_CHARACTER = 37;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly IDENTIFIER = 32;
    // (undocumented)
    ignoreWS: boolean;
    // (undocumented)
    static readonly INVALID_TOKEN_DEFAULT_MODE = 35;
    // (undocumented)
    static readonly LESS_OR_EQUAl = 16;
    // (undocumented)
    static readonly LESS_THAN = 14;
    // (undocumented)
    static readonly modeNames: string[];
    // (undocumented)
    readonly modeNames: string[];
    // (undocumented)
    static readonly MORE_OR_EQUAL = 17;
    // (undocumented)
    static readonly MORE_THAN = 15;
    // (undocumented)
    static readonly NEWLINE = 33;
    // (undocumented)
    static readonly NON = 4;
    // (undocumented)
    static readonly NOT_EQUAL = 10;
    // (undocumented)
    static readonly NULL_COALESCE = 28;
    // (undocumented)
    static readonly NUMBER = 30;
    // (undocumented)
    static readonly OPEN_BRACKET = 18;
    // (undocumented)
    static readonly OPEN_CURLY_BRACKET = 23;
    // (undocumented)
    static readonly OPEN_SQUARE_BRACKET = 21;
    // (undocumented)
    static readonly PERCENT = 8;
    // (undocumented)
    static readonly PLUS = 2;
    // (undocumented)
    static readonly QUESTION_MARK = 29;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    static readonly SINGLE_AND = 11;
    // (undocumented)
    static readonly SLASH = 7;
    // (undocumented)
    static readonly STRING = 34;
    // (undocumented)
    static readonly STRING_INTERPOLATION_MODE = 1;
    // (undocumented)
    static readonly STRING_INTERPOLATION_START = 1;
    // (undocumented)
    static readonly SUBSTRACT = 3;
    // (undocumented)
    static readonly TEMPLATE = 36;
    // (undocumented)
    static readonly TEXT_CONTENT = 38;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
    // (undocumented)
    static readonly WHITESPACE = 31;
    // (undocumented)
    static readonly XOR = 5;
}

// @public (undocumented)
export class ExpressionAntlrParser extends Parser {
    // (undocumented)
    static __ATN: ATN;
    constructor(input: TokenStream);
    // (undocumented)
    argsList(): ArgsListContext;
    // (undocumented)
    static readonly ARROW = 27;
    // (undocumented)
    static readonly ASTERISK = 6;
    // (undocumented)
    static readonly _ATN: ATN;
    // (undocumented)
    static readonly CLOSE_BRACKET = 19;
    // (undocumented)
    static readonly CLOSE_CURLY_BRACKET = 24;
    // (undocumented)
    static readonly CLOSE_SQUARE_BRACKET = 22;
    // (undocumented)
    static readonly COLON = 26;
    // (undocumented)
    static readonly COMMA = 25;
    // (undocumented)
    static readonly DOT = 20;
    // (undocumented)
    static readonly DOUBLE_AND = 12;
    // (undocumented)
    static readonly DOUBLE_EQUAL = 9;
    // (undocumented)
    static readonly DOUBLE_VERTICAL_CYLINDER = 13;
    // (undocumented)
    static readonly ESCAPE_CHARACTER = 37;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    expression(_p: number): ExpressionContext;
    // (undocumented)
    file(): FileContext;
    // (undocumented)
    readonly grammarFileName: string;
    // (undocumented)
    static readonly IDENTIFIER = 32;
    // (undocumented)
    static readonly INVALID_TOKEN_DEFAULT_MODE = 35;
    // (undocumented)
    key(): KeyContext;
    // (undocumented)
    keyValuePair(): KeyValuePairContext;
    // (undocumented)
    keyValuePairList(): KeyValuePairListContext;
    // (undocumented)
    lambda(): LambdaContext;
    // (undocumented)
    static readonly LESS_OR_EQUAl = 16;
    // (undocumented)
    static readonly LESS_THAN = 14;
    // (undocumented)
    static readonly MORE_OR_EQUAL = 17;
    // (undocumented)
    static readonly MORE_THAN = 15;
    // (undocumented)
    static readonly NEWLINE = 33;
    // (undocumented)
    static readonly NON = 4;
    // (undocumented)
    static readonly NOT_EQUAL = 10;
    // (undocumented)
    static readonly NULL_COALESCE = 28;
    // (undocumented)
    static readonly NUMBER = 30;
    // (undocumented)
    static readonly OPEN_BRACKET = 18;
    // (undocumented)
    static readonly OPEN_CURLY_BRACKET = 23;
    // (undocumented)
    static readonly OPEN_SQUARE_BRACKET = 21;
    // (undocumented)
    static readonly PERCENT = 8;
    // (undocumented)
    static readonly PLUS = 2;
    // (undocumented)
    primaryExpression(): PrimaryExpressionContext;
    // (undocumented)
    primaryExpression(_p: number): PrimaryExpressionContext;
    // (undocumented)
    static readonly QUESTION_MARK = 29;
    // (undocumented)
    static readonly RULE_argsList = 5;
    // (undocumented)
    static readonly RULE_expression = 1;
    // (undocumented)
    static readonly RULE_file = 0;
    // (undocumented)
    static readonly RULE_key = 9;
    // (undocumented)
    static readonly RULE_keyValuePair = 8;
    // (undocumented)
    static readonly RULE_keyValuePairList = 7;
    // (undocumented)
    static readonly RULE_lambda = 6;
    // (undocumented)
    static readonly RULE_primaryExpression = 2;
    // (undocumented)
    static readonly RULE_stringInterpolation = 3;
    // (undocumented)
    static readonly RULE_textContent = 4;
    // (undocumented)
    static readonly ruleNames: string[];
    // (undocumented)
    readonly ruleNames: string[];
    // (undocumented)
    sempred(_localctx: RuleContext, ruleIndex: number, predIndex: number): boolean;
    // (undocumented)
    readonly serializedATN: string;
    // (undocumented)
    static readonly _serializedATN: string;
    // (undocumented)
    static readonly SINGLE_AND = 11;
    // (undocumented)
    static readonly SLASH = 7;
    // (undocumented)
    static readonly STRING = 34;
    // (undocumented)
    static readonly STRING_INTERPOLATION_START = 1;
    // (undocumented)
    stringInterpolation(): StringInterpolationContext;
    // (undocumented)
    static readonly SUBSTRACT = 3;
    // (undocumented)
    static readonly TEMPLATE = 36;
    // (undocumented)
    static readonly TEXT_CONTENT = 38;
    // (undocumented)
    textContent(): TextContentContext;
    // (undocumented)
    static readonly VOCABULARY: Vocabulary;
    // (undocumented)
    readonly vocabulary: Vocabulary;
    // (undocumented)
    static readonly WHITESPACE = 31;
    // (undocumented)
    static readonly XOR = 5;
}

// @public
export interface ExpressionAntlrParserListener extends ParseTreeListener {
    enterArgsList?: (ctx: ArgsListContext) => void;
    enterArrayCreationExp?: (ctx: ArrayCreationExpContext) => void;
    enterBinaryOpExp?: (ctx: BinaryOpExpContext) => void;
    enterExpression?: (ctx: ExpressionContext) => void;
    enterFile?: (ctx: FileContext) => void;
    enterFuncInvokeExp?: (ctx: FuncInvokeExpContext) => void;
    enterIdAtom?: (ctx: IdAtomContext) => void;
    enterIndexAccessExp?: (ctx: IndexAccessExpContext) => void;
    enterJsonCreationExp?: (ctx: JsonCreationExpContext) => void;
    enterKey?: (ctx: KeyContext) => void;
    enterKeyValuePair?: (ctx: KeyValuePairContext) => void;
    enterKeyValuePairList?: (ctx: KeyValuePairListContext) => void;
    enterLambda?: (ctx: LambdaContext) => void;
    enterMemberAccessExp?: (ctx: MemberAccessExpContext) => void;
    enterNumericAtom?: (ctx: NumericAtomContext) => void;
    enterParenthesisExp?: (ctx: ParenthesisExpContext) => void;
    enterPrimaryExp?: (ctx: PrimaryExpContext) => void;
    enterPrimaryExpression?: (ctx: PrimaryExpressionContext) => void;
    enterStringAtom?: (ctx: StringAtomContext) => void;
    enterStringInterpolation?: (ctx: StringInterpolationContext) => void;
    enterStringInterpolationAtom?: (ctx: StringInterpolationAtomContext) => void;
    enterTextContent?: (ctx: TextContentContext) => void;
    enterTripleOpExp?: (ctx: TripleOpExpContext) => void;
    enterUnaryOpExp?: (ctx: UnaryOpExpContext) => void;
    exitArgsList?: (ctx: ArgsListContext) => void;
    exitArrayCreationExp?: (ctx: ArrayCreationExpContext) => void;
    exitBinaryOpExp?: (ctx: BinaryOpExpContext) => void;
    exitExpression?: (ctx: ExpressionContext) => void;
    exitFile?: (ctx: FileContext) => void;
    exitFuncInvokeExp?: (ctx: FuncInvokeExpContext) => void;
    exitIdAtom?: (ctx: IdAtomContext) => void;
    exitIndexAccessExp?: (ctx: IndexAccessExpContext) => void;
    exitJsonCreationExp?: (ctx: JsonCreationExpContext) => void;
    exitKey?: (ctx: KeyContext) => void;
    exitKeyValuePair?: (ctx: KeyValuePairContext) => void;
    exitKeyValuePairList?: (ctx: KeyValuePairListContext) => void;
    exitLambda?: (ctx: LambdaContext) => void;
    exitMemberAccessExp?: (ctx: MemberAccessExpContext) => void;
    exitNumericAtom?: (ctx: NumericAtomContext) => void;
    exitParenthesisExp?: (ctx: ParenthesisExpContext) => void;
    exitPrimaryExp?: (ctx: PrimaryExpContext) => void;
    exitPrimaryExpression?: (ctx: PrimaryExpressionContext) => void;
    exitStringAtom?: (ctx: StringAtomContext) => void;
    exitStringInterpolation?: (ctx: StringInterpolationContext) => void;
    exitStringInterpolationAtom?: (ctx: StringInterpolationAtomContext) => void;
    exitTextContent?: (ctx: TextContentContext) => void;
    exitTripleOpExp?: (ctx: TripleOpExpContext) => void;
    exitUnaryOpExp?: (ctx: UnaryOpExpContext) => void;
}

// @public
export interface ExpressionAntlrParserVisitor<Result> extends ParseTreeVisitor<Result> {
    visitArgsList?: (ctx: ArgsListContext) => Result;
    visitArrayCreationExp?: (ctx: ArrayCreationExpContext) => Result;
    visitBinaryOpExp?: (ctx: BinaryOpExpContext) => Result;
    visitExpression?: (ctx: ExpressionContext) => Result;
    visitFile?: (ctx: FileContext) => Result;
    visitFuncInvokeExp?: (ctx: FuncInvokeExpContext) => Result;
    visitIdAtom?: (ctx: IdAtomContext) => Result;
    visitIndexAccessExp?: (ctx: IndexAccessExpContext) => Result;
    visitJsonCreationExp?: (ctx: JsonCreationExpContext) => Result;
    visitKey?: (ctx: KeyContext) => Result;
    visitKeyValuePair?: (ctx: KeyValuePairContext) => Result;
    visitKeyValuePairList?: (ctx: KeyValuePairListContext) => Result;
    visitLambda?: (ctx: LambdaContext) => Result;
    visitMemberAccessExp?: (ctx: MemberAccessExpContext) => Result;
    visitNumericAtom?: (ctx: NumericAtomContext) => Result;
    visitParenthesisExp?: (ctx: ParenthesisExpContext) => Result;
    visitPrimaryExp?: (ctx: PrimaryExpContext) => Result;
    visitPrimaryExpression?: (ctx: PrimaryExpressionContext) => Result;
    visitStringAtom?: (ctx: StringAtomContext) => Result;
    visitStringInterpolation?: (ctx: StringInterpolationContext) => Result;
    visitStringInterpolationAtom?: (ctx: StringInterpolationAtomContext) => Result;
    visitTextContent?: (ctx: TextContentContext) => Result;
    visitTripleOpExp?: (ctx: TripleOpExpContext) => Result;
    visitUnaryOpExp?: (ctx: UnaryOpExpContext) => Result;
}

// @public (undocumented)
export class ExpressionContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    copyFrom(ctx: ExpressionContext): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class ExpressionConverter {
    convert(value: string | Expression): Expression;
}

// @public
export class ExpressionEvaluator {
    constructor(type: string, evaluator: EvaluateExpressionDelegate, returnType?: ReturnType_2, validator?: ValidateExpressionDelegate);
    negation: ExpressionEvaluator;
    returnType: ReturnType_2;
    tryEvaluate: (expression: Expression, state: MemoryInterface, options: Options) => ValueWithError;
    type: string;
    validateExpression: (expression: Expression) => void;
    }

// @public
export class ExpressionFunctions {
    static readonly standardFunctions: ReadonlyMap<string, ExpressionEvaluator>;
}

// @public
export class ExpressionParser implements ExpressionParserInterface {
    constructor(lookup?: EvaluatorLookup);
    protected static antlrParse(expression: string): ParseTree;
    readonly EvaluatorLookup: EvaluatorLookup;
    parse(expression: string): Expression;
}

// @public
export interface ExpressionParserInterface {
    parse(expression: string): Expression;
}

// @public
export class ExpressionProperty<T> {
    constructor(value?: T | string | Expression, defaultValue?: T);
    expressionText: string;
    getValue(data: object): T;
    setValue(value: T | string | Expression): void;
    toExpression(): Expression;
    toString(): string;
    tryGetValue(data: object): {
        value: T;
        error: Error;
    };
    value: T;
}

// @public
export class ExpressionType {
    // (undocumented)
    static readonly Abs: string;
    // (undocumented)
    static readonly Accessor: string;
    // (undocumented)
    static readonly Add: string;
    // (undocumented)
    static readonly AddDays: string;
    // (undocumented)
    static readonly AddHours: string;
    // (undocumented)
    static readonly AddMinutes: string;
    // (undocumented)
    static readonly AddOrdinal: string;
    // (undocumented)
    static readonly AddProperty: string;
    // (undocumented)
    static readonly AddSeconds: string;
    // (undocumented)
    static readonly AddToTime: string;
    // (undocumented)
    static readonly All: string;
    // (undocumented)
    static readonly And: string;
    // (undocumented)
    static readonly Any: string;
    // (undocumented)
    static readonly Average: string;
    // (undocumented)
    static readonly Base64: string;
    // (undocumented)
    static readonly Base64ToBinary: string;
    // (undocumented)
    static readonly Base64ToString: string;
    // (undocumented)
    static readonly Binary: string;
    // (undocumented)
    static readonly Bool: string;
    // (undocumented)
    static readonly Ceiling: string;
    // (undocumented)
    static readonly Coalesce: string;
    // (undocumented)
    static readonly Concat: string;
    // (undocumented)
    static readonly Constant: string;
    // (undocumented)
    static readonly Contains: string;
    // (undocumented)
    static readonly ConvertFromUTC: string;
    // (undocumented)
    static readonly ConvertToUTC: string;
    // (undocumented)
    static readonly Count: string;
    // (undocumented)
    static readonly CountWord: string;
    // (undocumented)
    static readonly CreateArray: string;
    // (undocumented)
    static readonly DataUri: string;
    // (undocumented)
    static readonly DataUriToBinary: string;
    // (undocumented)
    static readonly DataUriToString: string;
    // (undocumented)
    static readonly Date: string;
    // (undocumented)
    static readonly DateReadBack: string;
    // (undocumented)
    static readonly DateTimeDiff: string;
    // (undocumented)
    static readonly DayOfMonth: string;
    // (undocumented)
    static readonly DayOfWeek: string;
    // (undocumented)
    static readonly DayOfYear: string;
    // (undocumented)
    static readonly Divide: string;
    // (undocumented)
    static readonly Element: string;
    // (undocumented)
    static readonly Empty: string;
    // (undocumented)
    static readonly EndsWith: string;
    // (undocumented)
    static readonly EOL: string;
    // (undocumented)
    static readonly Equal: string;
    // (undocumented)
    static readonly Exists: string;
    // (undocumented)
    static readonly FilterNotEqual: string;
    // (undocumented)
    static readonly First: string;
    // (undocumented)
    static readonly Flatten: string;
    // (undocumented)
    static readonly Float: string;
    // (undocumented)
    static readonly Floor: string;
    // (undocumented)
    static readonly Foreach: string;
    // (undocumented)
    static readonly FormatDateTime: string;
    // (undocumented)
    static readonly FormatEpoch: string;
    // (undocumented)
    static readonly FormatNumber: string;
    // (undocumented)
    static readonly FormatTicks: string;
    // (undocumented)
    static readonly GetFutureTime: string;
    // (undocumented)
    static readonly GetNextViableDate: string;
    // (undocumented)
    static readonly GetNextViableTime: string;
    // (undocumented)
    static readonly GetPastTime: string;
    // (undocumented)
    static readonly GetPreviousViableDate: string;
    // (undocumented)
    static readonly GetPreviousViableTime: string;
    // (undocumented)
    static readonly GetProperty: string;
    // (undocumented)
    static readonly GetTimeOfDay: string;
    // (undocumented)
    static readonly GreaterThan: string;
    // (undocumented)
    static readonly GreaterThanOrEqual: string;
    // (undocumented)
    static readonly If: string;
    // (undocumented)
    static readonly Ignore: string;
    // (undocumented)
    static readonly IndexOf: string;
    // (undocumented)
    static readonly IndicesAndValues: string;
    // (undocumented)
    static readonly Int: string;
    // (undocumented)
    static readonly Intersection: string;
    // (undocumented)
    static readonly IsArray: string;
    // (undocumented)
    static readonly IsBoolean: string;
    // (undocumented)
    static readonly IsDate: string;
    // (undocumented)
    static readonly IsDateRange: string;
    // (undocumented)
    static readonly IsDateTime: string;
    // (undocumented)
    static readonly IsDefinite: string;
    // (undocumented)
    static readonly IsDuration: string;
    // (undocumented)
    static readonly IsFloat: string;
    // (undocumented)
    static readonly IsInteger: string;
    // (undocumented)
    static readonly IsMatch: string;
    // (undocumented)
    static readonly IsObject: string;
    // (undocumented)
    static readonly IsPresent: string;
    // (undocumented)
    static readonly IsString: string;
    // (undocumented)
    static readonly IsTime: string;
    // (undocumented)
    static readonly IsTimeRange: string;
    // (undocumented)
    static readonly Join: string;
    // (undocumented)
    static readonly JPath: string;
    // (undocumented)
    static readonly Json: string;
    // (undocumented)
    static readonly JsonStringify: string;
    // (undocumented)
    static readonly Lambda: string;
    // (undocumented)
    static readonly Last: string;
    // (undocumented)
    static readonly LastIndexOf: string;
    // (undocumented)
    static readonly Length: string;
    // (undocumented)
    static readonly LessThan: string;
    // (undocumented)
    static readonly LessThanOrEqual: string;
    // (undocumented)
    static readonly Max: string;
    // (undocumented)
    static readonly Merge: string;
    // (undocumented)
    static readonly Min: string;
    // (undocumented)
    static readonly Mod: string;
    // (undocumented)
    static readonly Month: string;
    // (undocumented)
    static readonly Multiply: string;
    // (undocumented)
    static readonly NewGuid: string;
    // (undocumented)
    static readonly Not: string;
    // (undocumented)
    static readonly NotEqual: string;
    // (undocumented)
    static readonly Optional: string;
    // (undocumented)
    static readonly Or: string;
    // (undocumented)
    static readonly Power: string;
    // (undocumented)
    static readonly Rand: string;
    // (undocumented)
    static readonly Range: string;
    // (undocumented)
    static readonly RemoveProperty: string;
    // (undocumented)
    static readonly Replace: string;
    // (undocumented)
    static readonly ReplaceIgnoreCase: string;
    // (undocumented)
    static readonly Reverse: string;
    // (undocumented)
    static readonly Round: string;
    // (undocumented)
    static readonly Select: string;
    // (undocumented)
    static readonly SentenceCase: string;
    // (undocumented)
    static readonly SetPathToValue: string;
    // (undocumented)
    static readonly SetProperty: string;
    // (undocumented)
    static readonly Skip: string;
    // (undocumented)
    static readonly SortBy: string;
    // (undocumented)
    static readonly SortByDescending: string;
    // (undocumented)
    static readonly Split: string;
    // (undocumented)
    static readonly Sqrt: string;
    // (undocumented)
    static readonly StartOfDay: string;
    // (undocumented)
    static readonly StartOfHour: string;
    // (undocumented)
    static readonly StartOfMonth: string;
    // (undocumented)
    static readonly StartsWith: string;
    // (undocumented)
    static readonly String: string;
    // (undocumented)
    static readonly StringOrValue: string;
    // (undocumented)
    static readonly SubArray: string;
    // (undocumented)
    static readonly Substring: string;
    // (undocumented)
    static readonly Subtract: string;
    // (undocumented)
    static readonly SubtractFromTime: string;
    // (undocumented)
    static readonly Sum: string;
    // (undocumented)
    static readonly Take: string;
    // (undocumented)
    static readonly Ticks: string;
    // (undocumented)
    static readonly TicksToDays: string;
    // (undocumented)
    static readonly TicksToHours: string;
    // (undocumented)
    static readonly TicksToMinutes: string;
    // (undocumented)
    static readonly TimexResolve: string;
    // (undocumented)
    static readonly TitleCase: string;
    // (undocumented)
    static readonly ToLower: string;
    // (undocumented)
    static readonly ToUpper: string;
    // (undocumented)
    static readonly Trim: string;
    // (undocumented)
    static readonly Union: string;
    // (undocumented)
    static readonly Unique: string;
    // (undocumented)
    static readonly UriComponent: string;
    // (undocumented)
    static readonly UriComponentToString: string;
    // (undocumented)
    static readonly UriHost: string;
    // (undocumented)
    static readonly UriPath: string;
    // (undocumented)
    static readonly UriPathAndQuery: string;
    // (undocumented)
    static readonly UriPort: string;
    // (undocumented)
    static readonly UriQuery: string;
    // (undocumented)
    static readonly UriScheme: string;
    // (undocumented)
    static readonly UtcNow: string;
    // (undocumented)
    static readonly Where: string;
    // (undocumented)
    static readonly XML: string;
    // (undocumented)
    static readonly XPath: string;
    // (undocumented)
    static readonly Year: string;
}

// @public
export class Extensions {
    static isMemoryInterface(obj: any): boolean;
    static randomNext(memory: MemoryInterface, min: number, max: number): number;
}

// @public (undocumented)
export class FileContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    EOF(): TerminalNode;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class FuncInvokeExpContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    argsList(): ArgsListContext | undefined;
    // (undocumented)
    CLOSE_BRACKET(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    NON(): TerminalNode | undefined;
    // (undocumented)
    OPEN_BRACKET(): TerminalNode;
    // (undocumented)
    primaryExpression(): PrimaryExpressionContext;
}

// @public
export class FunctionTable implements Map<string, ExpressionEvaluator> {
    readonly [Symbol.iterator]: () => IterableIterator<[string, ExpressionEvaluator]>;
    readonly [Symbol.toStringTag]: string;
    // (undocumented)
    add(item: {
        key: string;
        value: ExpressionEvaluator;
    }): void;
    // (undocumented)
    add(key: string, value: ExpressionEvaluator): void;
    // Warning: (ae-forgotten-export) The symbol "customFunction" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    add(key: string, value: customFunction): void;
    clear(): void;
    delete(key: string): boolean;
    entries(): IterableIterator<[string, ExpressionEvaluator]>;
    forEach(_callbackfn: (value: ExpressionEvaluator, key: string, map: Map<string, ExpressionEvaluator>) => void, _thisArg?: any): void;
    get(key: string): ExpressionEvaluator;
    has(key: string): boolean;
    readonly isReadOnly: boolean;
    keys(): IterableIterator<string>;
    set(key: string, value: ExpressionEvaluator): this;
    readonly size: number;
    values(): IterableIterator<ExpressionEvaluator>;
}

// @public
export class FunctionUtils {
    static apply(func: (arg0: unknown[]) => unknown, verify?: VerifyExpression): EvaluateExpressionDelegate;
    static applySequence(func: (arg0: any[]) => any, verify?: VerifyExpression): EvaluateExpressionDelegate;
    static applySequenceWithError(func: (arg0: any[]) => any, verify?: VerifyExpression): EvaluateExpressionDelegate;
    static applyWithError(func: (arg0: any[]) => ValueWithError, verify?: VerifyExpression): EvaluateExpressionDelegate;
    static applyWithOptions(func: (arg0: unknown[], options: Options) => unknown, verify?: VerifyExpression): EvaluateExpressionDelegate;
    static applyWithOptionsAndError(func: (arg0: unknown[], options: Options) => {
        value: unknown;
        error: string;
    }, verify?: VerifyExpression): EvaluateExpressionDelegate;
    static commonEquals(obj1: unknown, obj2: unknown): boolean;
    static readonly DefaultDateTimeFormat: string;
    // (undocumented)
    static determineFormatAndLocale(args: unknown[], maxArgsLength: number, format: string, locale?: string): {
        format: string;
        locale: string;
    };
    // (undocumented)
    static determineLocale(args: unknown[], maxArgsLength: number, locale?: string): string;
    static evaluateChildren(expression: Expression, state: MemoryInterface, options: Options, verify?: VerifyExpression): {
        args: any[];
        error: string;
    };
    static isNumber(instance: any): instance is number;
    static timestampFormatter(formatter: string): string;
    static tryAccumulatePath(expression: Expression, state: MemoryInterface, options: Options): {
        path: string;
        left: any;
        error: string;
    };
    static validateArityAndAnyType(expression: Expression, minArity: number, maxArity: number, returnType?: ReturnType_2): void;
    static validateAtLeastOne(expression: Expression): void;
    static validateBinary(expression: Expression): void;
    static validateBinaryNumber(expression: Expression): void;
    static validateBinaryNumberOrString(expression: Expression): void;
    static validateNumber(expression: Expression): void;
    static validateOrder(expression: Expression, optional: ReturnType_2[], ...types: ReturnType_2[]): void;
    static validateString(expression: Expression): void;
    static validateTwoOrMoreThanTwoNumbers(expression: Expression): void;
    static validateUnary(expression: Expression): void;
    static validateUnaryBoolean(expression: Expression): void;
    static validateUnaryNumber(expression: Expression): void;
    static validateUnaryOrBinaryNumber(expression: Expression): void;
    static validateUnaryOrBinaryString(expression: Expression): void;
    static validateUnaryString(expression: Expression): void;
    static verifyBoolean(value: any, expression: Expression, _: number): string | undefined;
    static verifyContainer(value: any, expression: Expression, _: number): string | undefined;
    static verifyContainerOrNull(value: unknown, expression: Expression, _: number): string | undefined;
    static verifyInteger(value: any, expression: Expression, _: number): string | undefined;
    static verifyList(value: any, expression: Expression): string | undefined;
    static verifyNotNull(value: any, expression: Expression, _: number): string | undefined;
    static verifyNumber(value: any, expression: Expression, _: number): string | undefined;
    static verifyNumberOrNumericList(value: any, expression: Expression, _: number): string | undefined;
    static verifyNumberOrString(value: any, expression: Expression, _: number): string | undefined;
    static verifyNumberOrStringOrNull(value: any, expression: Expression, _: number): string | undefined;
    static verifyNumericList(value: any, expression: Expression, _: number): string | undefined;
    static verifyString(value: any, expression: Expression, _: number): string | undefined;
    static verifyStringOrNull(value: any, expression: Expression, _: number): string | undefined;
}

// @public (undocumented)
export class IdAtomContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    IDENTIFIER(): TerminalNode;
}

// @public (undocumented)
export class IndexAccessExpContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    CLOSE_SQUARE_BRACKET(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    OPEN_SQUARE_BRACKET(): TerminalNode;
    // (undocumented)
    primaryExpression(): PrimaryExpressionContext;
}

// @public
export class IntExpression extends ExpressionProperty<number> {
    constructor(value?: number | string | Expression);
    setValue(value: number | string | Expression): void;
    tryGetValue(data: object): {
        value: number;
        error: Error;
    };
}

// @public
export class IntExpressionConverter {
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input_4 | IntExpression): IntExpression;
}

// @public (undocumented)
export class JsonCreationExpContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    CLOSE_CURLY_BRACKET(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    keyValuePairList(): KeyValuePairListContext | undefined;
    // (undocumented)
    OPEN_CURLY_BRACKET(): TerminalNode;
}

// @public (undocumented)
export class KeyContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    IDENTIFIER(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRING(): TerminalNode | undefined;
}

// @public (undocumented)
export class KeyValuePairContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    COLON(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    key(): KeyContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class KeyValuePairListContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    COMMA(): TerminalNode[];
    // (undocumented)
    COMMA(i: number): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    keyValuePair(): KeyValuePairContext[];
    // (undocumented)
    keyValuePair(i: number): KeyValuePairContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class LambdaContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    ARROW(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    IDENTIFIER(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class LetterContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    ALC(): TerminalNode | undefined;
    // (undocumented)
    AUC(): TerminalNode | undefined;
    // (undocumented)
    BLC(): TerminalNode | undefined;
    // (undocumented)
    BUC(): TerminalNode | undefined;
    // (undocumented)
    CLC(): TerminalNode | undefined;
    // (undocumented)
    CUC(): TerminalNode | undefined;
    // (undocumented)
    DLC(): TerminalNode | undefined;
    // (undocumented)
    DUC(): TerminalNode | undefined;
    // (undocumented)
    ELC(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    EUC(): TerminalNode | undefined;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    FLC(): TerminalNode | undefined;
    // (undocumented)
    FUC(): TerminalNode | undefined;
    // (undocumented)
    GLC(): TerminalNode | undefined;
    // (undocumented)
    GUC(): TerminalNode | undefined;
    // (undocumented)
    HLC(): TerminalNode | undefined;
    // (undocumented)
    HUC(): TerminalNode | undefined;
    // (undocumented)
    ILC(): TerminalNode | undefined;
    // (undocumented)
    IUC(): TerminalNode | undefined;
    // (undocumented)
    JLC(): TerminalNode | undefined;
    // (undocumented)
    JUC(): TerminalNode | undefined;
    // (undocumented)
    KLC(): TerminalNode | undefined;
    // (undocumented)
    KUC(): TerminalNode | undefined;
    // (undocumented)
    LLC(): TerminalNode | undefined;
    // (undocumented)
    LUC(): TerminalNode | undefined;
    // (undocumented)
    MLC(): TerminalNode | undefined;
    // (undocumented)
    MUC(): TerminalNode | undefined;
    // (undocumented)
    NLC(): TerminalNode | undefined;
    // (undocumented)
    NUC(): TerminalNode | undefined;
    // (undocumented)
    OLC(): TerminalNode | undefined;
    // (undocumented)
    OUC(): TerminalNode | undefined;
    // (undocumented)
    PLC(): TerminalNode | undefined;
    // (undocumented)
    PUC(): TerminalNode | undefined;
    // (undocumented)
    QLC(): TerminalNode | undefined;
    // (undocumented)
    QUC(): TerminalNode | undefined;
    // (undocumented)
    RLC(): TerminalNode | undefined;
    // (undocumented)
    RUC(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    SLC(): TerminalNode | undefined;
    // (undocumented)
    SUC(): TerminalNode | undefined;
    // (undocumented)
    TLC(): TerminalNode | undefined;
    // (undocumented)
    TUC(): TerminalNode | undefined;
    // (undocumented)
    ULC(): TerminalNode | undefined;
    // (undocumented)
    UUC(): TerminalNode | undefined;
    // (undocumented)
    VLC(): TerminalNode | undefined;
    // (undocumented)
    VUC(): TerminalNode | undefined;
    // (undocumented)
    WLC(): TerminalNode | undefined;
    // (undocumented)
    WUC(): TerminalNode | undefined;
    // (undocumented)
    XLC(): TerminalNode | undefined;
    // (undocumented)
    XUC(): TerminalNode | undefined;
    // (undocumented)
    YLC(): TerminalNode | undefined;
    // (undocumented)
    YUC(): TerminalNode | undefined;
    // (undocumented)
    ZLC(): TerminalNode | undefined;
    // (undocumented)
    ZUC(): TerminalNode | undefined;
}

// @public (undocumented)
export class LiteralContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    CharacterClassEnd(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    shared_literal(): Shared_literalContext | undefined;
}

// @public
export const localeInfo: {
    'ar-MA': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'en-IN': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-BH': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-PS': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'en-IE': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'it-IT': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-EG': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-IQ': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-EH': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-AE': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-MR': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'uk-UA': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ca-ES': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'sv-SE': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ja-JP': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'es-ES': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'fi-FI': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-DZ': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'en-GB': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'cs-CZ': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-TD': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'de-CH': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'nl-NL': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'es-BO': {
        currency: string[];
        decimal: string;
        percent: string;
        thousands: string;
        grouping: number[];
    };
    'ar-SY': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-JO': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'en-CA': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-ER': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-LB': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'fr-CA': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-TN': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-YE': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ru-RU': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'en-US': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-SS': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-SO': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'hu-HU': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'pt-BR': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-DJ': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-SD': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-001': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-LY': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-SA': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'ar-KW': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'pl-PL': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-QA': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'mk-MK': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ko-KR': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'es-MX': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-IL': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'zh-CN': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'de-DE': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
    'ar-OM': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'fr-FR': {
        currency: string[];
        decimal: string;
        percent: string;
        thousands: string;
        grouping: number[];
    };
    'ar-KM': {
        currency: string[];
        decimal: string;
        thousands: string;
        numerals: string[];
        grouping: number[];
    };
    'he-IL': {
        currency: string[];
        decimal: string;
        thousands: string;
        grouping: number[];
    };
};

// @public (undocumented)
export class MemberAccessExpContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    DOT(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    IDENTIFIER(): TerminalNode;
    // (undocumented)
    primaryExpression(): PrimaryExpressionContext;
}

// @public
export interface MemoryInterface {
    getValue(path: string): any;
    setValue(path: string, value: any): void;
    version(): string;
}

// @public
export class MultivariateNumericEvaluator extends ExpressionEvaluator {
    constructor(type: string, func: (args: any[]) => number, verify?: VerifyExpression);
    }

// @public (undocumented)
export class NameContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    alpha_nums(): Alpha_numsContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
class Node_2 {
    constructor(clause: Clause, tree: TriggerTree, trigger?: Trigger);
    addNode(triggerNode: Node_2): boolean;
    readonly allTriggers: Trigger[];
    clause: Clause;
    matches(state: MemoryInterface | any): Trigger[];
    relationship(other: Node_2): RelationshipType;
    removeTrigger(trigger: Trigger): boolean;
    readonly specializations: Node_2[];
    toString(builder?: string[], indent?: number): string;
    tree: TriggerTree;
    readonly triggers: Trigger[];
    }

export { Node_2 as Node }

// @public (undocumented)
export class Non_captureContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    alternation(): AlternationContext;
    // (undocumented)
    CloseParen(): TerminalNode;
    // (undocumented)
    Colon(): TerminalNode;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    OpenParen(): TerminalNode;
    // (undocumented)
    QuestionMark(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class Non_close_parenContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    CloseParen(): TerminalNode;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class Non_close_parensContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    non_close_paren(): Non_close_parenContext[];
    // (undocumented)
    non_close_paren(i: number): Non_close_parenContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class NumberContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    digits(): DigitsContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class NumberExpression extends ExpressionProperty<number> {
    constructor(value?: number | string | Expression);
    setValue(value: number | string | Expression): void;
}

// @public
export class NumberExpressionConverter {
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input_5 | NumberExpression): NumberExpression;
}

// @public
export class NumberTransformEvaluator extends ExpressionEvaluator {
    constructor(type: string, func: (args: any[]) => number);
    }

// @public (undocumented)
export class NumericAtomContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    NUMBER(): TerminalNode;
}

// @public
export class NumericEvaluator extends ExpressionEvaluator {
    constructor(type: string, func: (args: any[]) => any);
    }

// @public
export class ObjectExpression<T> extends ExpressionProperty<T> {
    constructor(value?: T | string | Expression);
}

// @public
export class ObjectExpressionConverter<T extends object = {}> {
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input_6<T> | ObjectExpression<T>): ObjectExpression<T>;
}

// @public (undocumented)
export class Octal_charContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    Backslash(): TerminalNode | undefined;
    // (undocumented)
    D0(): TerminalNode | undefined;
    // (undocumented)
    D1(): TerminalNode | undefined;
    // (undocumented)
    D2(): TerminalNode | undefined;
    // (undocumented)
    D3(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    octal_digit(): Octal_digitContext[];
    // (undocumented)
    octal_digit(i: number): Octal_digitContext;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class Octal_digitContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    D0(): TerminalNode | undefined;
    // (undocumented)
    D1(): TerminalNode | undefined;
    // (undocumented)
    D2(): TerminalNode | undefined;
    // (undocumented)
    D3(): TerminalNode | undefined;
    // (undocumented)
    D4(): TerminalNode | undefined;
    // (undocumented)
    D5(): TerminalNode | undefined;
    // (undocumented)
    D6(): TerminalNode | undefined;
    // (undocumented)
    D7(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export interface Optimizer {
    optimize(clause: Clause): Clause;
}

// @public (undocumented)
export class Option_flagContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    ILC(): TerminalNode | undefined;
    // (undocumented)
    MLC(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    SLC(): TerminalNode | undefined;
}

// @public (undocumented)
export class OptionContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    CloseParen(): TerminalNode;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    OpenParen(): TerminalNode;
    // (undocumented)
    option_flag(): Option_flagContext[];
    // (undocumented)
    option_flag(i: number): Option_flagContext;
    // (undocumented)
    QuestionMark(): TerminalNode;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class Options {
    constructor(opt?: Options);
    locale: string;
    // (undocumented)
    nullSubstitution: (path: string) => unknown;
}

// @public (undocumented)
export class ParenthesisExpContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    CLOSE_BRACKET(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    OPEN_BRACKET(): TerminalNode;
}

// @public (undocumented)
export class ParseContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    alternation(): AlternationContext;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    EOF(): TerminalNode;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class ParseErrorListener implements ANTLRErrorListener<any> {
    // (undocumented)
    static readonly Instance: ParseErrorListener;
    syntaxError<T>(_recognizer: Recognizer<T, any>, _offendingSymbol: T, line: number, charPositionInLine: number, _msg: string, _e: RecognitionException | undefined): void;
}

// @public
export interface PredicateComparer {
    predicate: string;
    relationship(predicate: Expression, other: Expression): RelationshipType;
}

// @public (undocumented)
export type PredicateComparers = {
    [name: string]: PredicateComparer;
};

// @public (undocumented)
export class PrimaryExpContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    primaryExpression(): PrimaryExpressionContext;
}

// @public (undocumented)
export class PrimaryExpressionContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    copyFrom(ctx: PrimaryExpressionContext): void;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public
export class Quantifier {
    constructor(variable: string, type: QuantifierType, bindings: string[]);
    // (undocumented)
    readonly bindings: string[];
    // (undocumented)
    toString(): string;
    // (undocumented)
    readonly type: QuantifierType;
    // (undocumented)
    readonly variable: string;
}

// @public (undocumented)
export class Quantifier_typeContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    Plus(): TerminalNode | undefined;
    // (undocumented)
    QuestionMark(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
}

// @public (undocumented)
export class QuantifierContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    CloseBrace(): TerminalNode | undefined;
    // (undocumented)
    Comma(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    number(): NumberContext[];
    // (undocumented)
    number(i: number): NumberContext;
    // (undocumented)
    OpenBrace(): TerminalNode | undefined;
    // (undocumented)
    Plus(): TerminalNode | undefined;
    // (undocumented)
    quantifier_type(): Quantifier_typeContext;
    // (undocumented)
    QuestionMark(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    Star(): TerminalNode | undefined;
}

// @public
export enum QuantifierType {
    all = "all",
    any = "any"
}

// @public
export class RegexErrorListener implements ANTLRErrorListener<any> {
    // (undocumented)
    static readonly Instance: RegexErrorListener;
    syntaxError<T>(_recognizer: Recognizer<T, any>, _offendingSymbol: T, _line: number, _charPositionInLine: number, _msg: string, _e: RecognitionException | undefined): void;
}

// @public
export enum RelationshipType {
    equal = "equal",
    generalizes = "generalizes",
    incomparable = "incomparable",
    specializes = "specializes"
}

// @public
enum ReturnType_2 {
    Array = 16,
    Boolean = 1,
    Number = 2,
    Object = 4,
    String = 8
}

export { ReturnType_2 as ReturnType }

// @public (undocumented)
export class Shared_atomContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    CharWithoutProperty(): TerminalNode | undefined;
    // (undocumented)
    CharWithProperty(): TerminalNode | undefined;
    // (undocumented)
    ControlChar(): TerminalNode | undefined;
    // (undocumented)
    DecimalDigit(): TerminalNode | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    NotDecimalDigit(): TerminalNode | undefined;
    // (undocumented)
    NotWhiteSpace(): TerminalNode | undefined;
    // (undocumented)
    NotWordChar(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    WhiteSpace(): TerminalNode | undefined;
    // (undocumented)
    WordChar(): TerminalNode | undefined;
}

// @public (undocumented)
export class Shared_literalContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: CommonRegexVisitor<Result>): Result;
    // (undocumented)
    Ampersand(): TerminalNode | undefined;
    // (undocumented)
    BellChar(): TerminalNode | undefined;
    // (undocumented)
    BlockQuoted(): TerminalNode | undefined;
    // (undocumented)
    CarriageReturn(): TerminalNode | undefined;
    // (undocumented)
    CloseBrace(): TerminalNode | undefined;
    // (undocumented)
    Colon(): TerminalNode | undefined;
    // (undocumented)
    Comma(): TerminalNode | undefined;
    // (undocumented)
    digit(): DigitContext | undefined;
    // (undocumented)
    enterRule(listener: CommonRegexListener): void;
    // (undocumented)
    Equals(): TerminalNode | undefined;
    // (undocumented)
    EscapeChar(): TerminalNode | undefined;
    // (undocumented)
    Exclamation(): TerminalNode | undefined;
    // (undocumented)
    exitRule(listener: CommonRegexListener): void;
    // (undocumented)
    FormFeed(): TerminalNode | undefined;
    // (undocumented)
    GreaterThan(): TerminalNode | undefined;
    // (undocumented)
    Hash(): TerminalNode | undefined;
    // (undocumented)
    HexChar(): TerminalNode | undefined;
    // (undocumented)
    Hyphen(): TerminalNode | undefined;
    // (undocumented)
    LessThan(): TerminalNode | undefined;
    // (undocumented)
    letter(): LetterContext | undefined;
    // (undocumented)
    NewLine(): TerminalNode | undefined;
    // (undocumented)
    octal_char(): Octal_charContext | undefined;
    // (undocumented)
    OpenBrace(): TerminalNode | undefined;
    // (undocumented)
    OtherChar(): TerminalNode | undefined;
    // (undocumented)
    Quoted(): TerminalNode | undefined;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    SingleQuote(): TerminalNode | undefined;
    // (undocumented)
    Tab(): TerminalNode | undefined;
    // (undocumented)
    Underscore(): TerminalNode | undefined;
}

// @public
export class SimpleObjectMemory implements MemoryInterface {
    constructor(memory: any);
    getValue(path: string): any;
    setValue(path: string, input: any): void;
    toString(): string;
    version(): string;
    static wrap(obj: any): MemoryInterface;
}

// @public
export class StackedMemory extends Array<MemoryInterface> implements MemoryInterface {
    getValue(path: string): any;
    setValue(_path: string, _value: any): void;
    version(): string;
    static wrap(memory: MemoryInterface): StackedMemory;
}

// @public (undocumented)
export class StringAtomContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    STRING(): TerminalNode;
}

// @public
export class StringExpression extends ExpressionProperty<string> {
    constructor(value?: string | Expression);
    setValue(value: string | Expression): void;
}

// @public
export class StringExpressionConverter {
    // Warning: (ae-forgotten-export) The symbol "Input" needs to be exported by the entry point index.d.ts
    convert(value: Input_7 | StringExpression): StringExpression;
}

// @public (undocumented)
export class StringInterpolationAtomContext extends PrimaryExpressionContext {
    constructor(ctx: PrimaryExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    stringInterpolation(): StringInterpolationContext;
}

// @public (undocumented)
export class StringInterpolationContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    ESCAPE_CHARACTER(): TerminalNode[];
    // (undocumented)
    ESCAPE_CHARACTER(i: number): TerminalNode;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    STRING_INTERPOLATION_START(): TerminalNode[];
    // (undocumented)
    STRING_INTERPOLATION_START(i: number): TerminalNode;
    // (undocumented)
    TEMPLATE(): TerminalNode[];
    // (undocumented)
    TEMPLATE(i: number): TerminalNode;
    // (undocumented)
    textContent(): TextContentContext[];
    // (undocumented)
    textContent(i: number): TextContentContext;
}

// @public
export class StringTransformEvaluator extends ExpressionEvaluator {
    constructor(type: string, func: (arg0: any[], options: Options) => string, validator?: (expr: Expression) => void);
}

// @public (undocumented)
export class TextContentContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    readonly ruleIndex: number;
    // (undocumented)
    TEXT_CONTENT(): TerminalNode[];
    // (undocumented)
    TEXT_CONTENT(i: number): TerminalNode;
}

// @public
export class TimeTransformEvaluator extends ExpressionEvaluator {
    constructor(type: string, func: (timestamp: Date, numOfTransformation: number) => Date);
    }

// @public
export class TimeZoneConverter {
    static ianaToWindows(ianaTimeZoneId: string): string;
    static verifyTimeZoneStr(timezoneStr: string): boolean;
    static windowsToIana(windowsTimeZoneId: string): string;
    }

// @public
export class Trigger {
    constructor(tree: TriggerTree, expression?: Expression, action?: any, ...quantifiers: Quantifier[]);
    readonly action: any;
    readonly clauses: Clause[];
    matches(nodeClause: Clause, state: MemoryInterface | any): boolean;
    readonly originalExpression: Expression;
    relationship(other: Trigger, comparers: PredicateComparers): RelationshipType;
    toString(builder?: string[], indent?: number): string;
    }

// @public
export class TriggerTree {
    constructor();
    addTrigger(stringOrExpression: string | Expression, action: any, ...quantifiers: Quantifier[]): Trigger;
    readonly comparers: PredicateComparers;
    matches(state: MemoryInterface | any): Trigger[];
    readonly optimizers: Optimizer[];
    removeTrigger(trigger: Trigger): boolean;
    root: Node_2;
    // (undocumented)
    toString(): string;
    totalTriggers: number;
    treeToString(indent?: number): string;
    verifyTree(): Node_2;
    }

// @public (undocumented)
export class TripleOpExpContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    COLON(): TerminalNode;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext[];
    // (undocumented)
    expression(i: number): ExpressionContext;
    // (undocumented)
    QUESTION_MARK(): TerminalNode;
}

// @public (undocumented)
export class UnaryOpExpContext extends ExpressionContext {
    constructor(ctx: ExpressionContext);
    // (undocumented)
    accept<Result>(visitor: ExpressionAntlrParserVisitor<Result>): Result;
    // (undocumented)
    enterRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    exitRule(listener: ExpressionAntlrParserListener): void;
    // (undocumented)
    expression(): ExpressionContext;
    // (undocumented)
    NON(): TerminalNode | undefined;
    // (undocumented)
    PLUS(): TerminalNode | undefined;
    // (undocumented)
    SUBSTRACT(): TerminalNode | undefined;
}

// @public
export class Util {
    static trim(str: string, char: string): string;
}

// @public
export type ValidateExpressionDelegate = (expression: Expression) => any;

// @public
export class ValueExpression extends ExpressionProperty<any> {
    constructor(value?: any | string | Expression);
    setValue(value: any | string | Expression): void;
}

// @public
export class ValueExpressionConverter {
    convert(value: unknown | ValueExpression): ValueExpression;
}

// @public
export type ValueWithError = {
    value: any;
    error: string;
};

// @public
export type VerifyExpression = (value: any, expression: Expression, child: number) => string | undefined;


// (No @packageDocumentation comment for this package)

```
